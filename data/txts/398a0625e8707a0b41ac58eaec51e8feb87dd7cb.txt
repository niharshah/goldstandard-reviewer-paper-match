Published as a conference paper at ICLR 2021

arXiv:2010.03768v2 [cs.CL] 14 Mar 2021

ALFWORLD: ALIGNING TEXT AND EMBODIED ENVIRONMENTS FOR INTERACTIVE LEARNING

Mohit Shridhar‚Ä† Xingdi Yuan‚ô°

Marc-Alexandre C√¥t√©‚ô°

Yonatan Bisk‚Ä° Adam Trischler‚ô° Matthew Hausknecht‚ô£

‚Ä†University of Washington

‚ô°Microsoft Research, Montr√©al

‚Ä°Carnegie Mellon University

‚ô£Microsoft Research

ALFWorld.github.io

ABSTRACT
Given a simple request like Put a washed apple in the kitchen fridge, humans can reason in purely abstract terms by imagining action sequences and scoring their likelihood of success, prototypicality, and efÔ¨Åciency, all without moving a muscle. Once we see the kitchen in question, we can update our abstract plans to Ô¨Åt the scene. Embodied agents require the same abilities, but existing work does not yet provide the infrastructure necessary for both reasoning abstractly and executing concretely. We address this limitation by introducing ALFWorld, a simulator that enables agents to learn abstract, text-based policies in TextWorld (C√¥t√© et al., 2018) and then execute goals from the ALFRED benchmark (Shridhar et al., 2020) in a rich visual environment. ALFWorld enables the creation of a new BUTLER agent whose abstract knowledge, learned in TextWorld, corresponds directly to concrete, visually grounded actions. In turn, as we demonstrate empirically, this fosters better agent generalization than training only in the visually grounded environment. BUTLER‚Äôs simple, modular design factors the problem to allow researchers to focus on models for improving every piece of the pipeline (language understanding, planning, navigation, and visual scene understanding).

1 INTRODUCTION

TextWorld

Embodied

Consider helping a friend prepare dinner in an unfamiliar house: when your friend asks you to clean and slice an apple for an appetizer, how would you approach the task? Intuitively, one could reason abstractly: (1) Ô¨Ånd an apple (2) wash the apple in the sink (3) put the clean apple on the cutting board (4) Ô¨Ånd a knife (5) use the knife to slice the apple (6) put the slices in a bowl. Even in an unfamiliar setting, abstract reasoning can help accomplish the goal by leveraging semantic priors. Priors like locations of objects ‚Äì apples are commonly found in the kitchen along with implements for cleaning and slicing, object affordances ‚Äì a sink is useful for washing an apple unlike a refrigerator, pre-conditions ‚Äì better to wash an apple before slicing it, rather than the converse. We hypothesize that, learning to solve tasks using abstract language, unconstrained by the particulars of the physical world, enables agents to complete embodied tasks in novel environments by leveraging the kinds of semantic priors that are exposed by abstraction and interaction.

Welcome!
You are in the middle of the room. Looking around you, you see a diningtable, a stove, a microwave, and a cabinet.
Your task is to: Put a pan on the diningtable.
> goto the cabinet
You arrive at the cabinet. The cabinet is closed.
> open the cabinet
The cabinet is empty.
> goto the stove
You arrive at the stove. Near the stove, you see a pan, a pot, a bread loaf, a lettuce, and a winebottle.
> take the pan from the stove
You take the pan from the stove.
> goto the diningtable
You arrive at the diningtable.
> put the pan on the diningtable
You put the pan on the diningtable.
Figure 1: ALFWorld: Interactive aligned text and embodied worlds. An example with high-level text actions (left) and low-level physical actions (right).

1

Published as a conference paper at ICLR 2021

To test this hypothesis, we have created the novel ALFWorld framework, the Ô¨Årst interactive, parallel environment that aligns text descriptions and commands with physically embodied robotic simulation. We build ALFWorld by extending two prior works: TextWorld (C√¥t√© et al., 2018) - an engine for interactive text-based games, and ALFRED (Shridhar et al., 2020) - a large scale dataset for visionlanguage instruction following in embodied environments. ALFWorld provides two views of the same underlying world and two modes by which to interact with it: TextWorld, an abstract, text-based environment, generates textual observations of the world and responds to high-level text actions; ALFRED, the embodied simulator, renders the world in high-dimensional images and responds to low-level physical actions as from a robot (Figure 1).1 Unlike prior work on instruction following (MacMahon et al., 2006; Anderson et al., 2018a), which typically uses a static corpus of cross-modal expert demonstrations, we argue that aligned parallel environments like ALFWorld offer a distinct advantage: they allow agents to explore, interact, and learn in the abstract environment of language before encountering the complexities of the embodied environment.
While Ô¨Åelds such as robotic control use simulators like MuJoCo (Todorov et al., 2012) to provide inÔ¨Ånite data through interaction, there has been no analogous mechanism ‚Äì short of hiring a human around the clock ‚Äì for providing linguistic feedback and annotations to an embodied agent. TextWorld addresses this discrepancy by providing programmatic and aligned linguistic signals during agent exploration. This facilitates the Ô¨Årst work, to our knowledge, in which an embodied agent learns the meaning of complex multi-step policies, expressed in language, directly through interaction.
Empowered by the ALFWorld framework, we introduce BUTLER (Building Understanding in Textworld via Language for Embodied Reasoning), an agent that Ô¨Årst learns to perform abstract tasks in TextWorld using Imitation Learning (IL) and then transfers the learned policies to embodied tasks in ALFRED. When operating in the embodied world, BUTLER leverages the abstract understanding gained from TextWorld to generate text-based actions; these serve as high-level subgoals that facilitate physical action generation by a low-level controller. Broadly, we Ô¨Ånd that BUTLER is capable of generalizing in a zero-shot manner from TextWorld to unseen embodied tasks and settings. Our results show that training Ô¨Årst in the abstract text-based environment is not only 7√ó faster, but also yields better performance than training from scratch in the embodied world. These results lend credibility to the hypothesis that solving abstract language-based tasks can help build priors that enable agents to generalize to unfamiliar embodied environments.
Our contributions are as follows:
¬ß 2 ALFWorld environment: The Ô¨Årst parallel interactive text-based and embodied environment.
¬ß 3 BUTLER architecture: An agent that learns high-level policies in language that transfer to low-level embodied executions, and whose modular components can be independently upgraded.
¬ß 4 Generalization: We demonstrate empirically that BUTLER, trained in the abstract text domain, generalizes better to unseen embodied settings than agents trained from corpora of demonstrations or from scratch in the embodied world.

2 ALIGNING ALFRED AND TEXTWORLD

The ALFRED dataset (Shridhar et al., 2020), set in the THOR simulator (Kolve et al., 2017), is a benchmark for learning to complete embodied household tasks using natural language instruc-

Task type Pick & Place Examine in Light Clean & Place

# train # seen # unseen 790 35 24 308 13 18 650 27 31

tions and egocentric visual observations. As shown in Figure 1 Heat & Place

459 16 23

(right), ALFRED tasks pose challenging interaction and naviga-

Cool & Place Pick Two & Place

533 813

25 24

21 17

tion problems to an agent in a high-Ô¨Ådelity simulated environment. All

3,553 140 134

Tasks are annotated with a goal description that describes the objective (e.g., ‚Äúput a pan on the dining table‚Äù). We consider both template-based and human-annotated goals; further details on goal speciÔ¨Åcation can be found in Appendix H. Agents observe

Table 1: Six ALFRED task types with heldout seen and unseen evaluation sets.

the world through high-dimensional pixel images and interact using low-level action primitives:

MOVEAHEAD, ROTATELEFT/RIGHT, LOOKUP/DOWN, PICKUP, PUT, OPEN, CLOSE, and TOGGLEON/OFF.

1Note: Throughout this work, for clarity of exposition, we use ALFRED to refer to both tasks and the grounded simulation environment, but rendering and physics are provided by THOR (Kolve et al., 2017).

2

Published as a conference paper at ICLR 2021

The ALFRED dataset also includes crowdsourced language instructions like ‚Äúturn around and walk over to the microwave‚Äù that explain how to complete a goal in a step-by-step manner. We depart from the ALFRED challenge by omitting these step-by-step instructions and focusing on the more diffcult problem of using only on goal descriptions specifying what needs to be achieved.
Our aligned ALFWorld framework adopts six ALFRED task-types (Table 1) of various difÔ¨Åculty levels.2 Tasks involve Ô¨Årst Ô¨Ånding a particular object, which often requires the agent to open and search receptacles like drawers or cabinets. Subsequently, all tasks other than Pick & Place require some interaction with the object such as heating (place object in microwave and start it) or cleaning (wash object in a sink). To complete the task, the object must be placed in the designated location.
Within each task category there is signiÔ¨Åcant variation: the embodied environment includes 120 rooms (30 kitchens, 30 bedrooms, 30 bathrooms, 30 living rooms), each dynamically populated with a set of portable objects (e.g., apple, mug), and static receptacles (e.g., microwave, fridge). For each task type we construct a larger train set, as well as seen and unseen validation evaluation sets: (1): seen consists of known task instances {task-type, object, receptacle, room} in rooms seen during training, but with different instantiations of object locations, quantities, and visual appearances (e.g. two blue pencils on a shelf instead of three red pencils in a drawer seen in training). (2): unseen consists of new task instances with possibly known object-receptacle pairs, but always in unseen rooms with different receptacles and scene layouts than in training tasks.
The seen set is designed to measure in-distribution generalization, whereas the unseen set measures out-of-distribution generalization. The scenes in ALFRED are visually diverse, so even the same task instance can lead to very distinct tasks, e.g., involving differently colored apples, shaped statues, or textured cabinets. For this reason, purely vision-based agents such as the unimodal baselines in Section 5.2 often struggle to generalize to unseen environments and objects.
The TextWorld framework (C√¥t√© et al., 2018) procedurally generates text-based environments for training and evaluating language-based agents. In order to extend TextWorld to create text-based analogs of each ALFRED scene, we adopt a common latent structure representing the state of the simulated world. ALFWorld uses PDDL - Planning Domain DeÔ¨Ånition Language (McDermott et al., 1998) to describe each scene from ALFRED and to construct an equivalent text game using the TextWorld engine. The dynamics of each game are deÔ¨Åned by the PDDL domain (see Appendix C for additional details). Textual observations shown in Figure 1 are generated with templates sampled from a context-sensitive grammar designed for the ALFRED environments. For interaction, TextWorld environments use the following high-level actions:

goto {recep} open {recep} clean {obj} with {recep}

take {obj} from {recep} close {recep} heat {obj} with {recep}

put {obj} in/on {recep} toggle {obj}{recep} cool {obj} with {recep}

where {obj} and {recep} correspond to objects and receptacles. Note that heat, cool, clean, and goto are high-level actions that correspond to several low-level embodied actions.
ALFWorld, in summary, is an cross-modal framework featuring a diversity of embodied tasks with analogous text-based counterparts. Since both components are fully interactive, agents may be trained in either the language or embodied world and evaluated on heldout test tasks in either modality. We believe the equivalence between objects and interactions across modalities make ALFWorld an ideal framework for studying language grounding and cross-modal learning.

3 INTRODUCING BUTLER: AN EMBODIED MULTI-TASK AGENT
We investigate learning in the abstract language modality before generalizing to the embodied setting. The BUTLER agent uses three components to span the language and embodied modalities: BUTLER::BRAIN ‚Äì the abstract text agent, BUTLER::VISION ‚Äì the language state estimator, and BUTLER::BODY ‚Äì the low-level controller. An overview of BUTLER is shown in Figure 2 and each component is described below.
2To start with, we focus on a subset of the ALFRED dataset for training and evaluation that excludes tasks involving slicing objects or using portable container (e.g., bowls).

3

Published as a conference paper at ICLR 2021

t =0

t =T

Pickup(

)

vt+1

Controller
(Body)

Looking around you, you see a shelf 1,

‚Äúput two plates on the coffeetable‚Äù

a dining table 1, a sofa 1, a coffeetable 2 ...

o0 g at

State Estimator
(Vision)

vt

On the dining table 1, ot

Text Agent

you see a laptop 1,

a plate 1, a vase 1,

(Brain)

a statue 1, and a statue 2.

ot
...

take plate 1 from dining table 1
at

Textworld Engine
Pre-training

Figure 2: BUTLER Agent consists of three modular components. 1) BUTLER::BRAIN: a text agent
pre-trained with the TextWorld engine (indicated by the dashed yellow box) which simulates an
abstract textual equivalent of the embodied world. When subsequently applied to embodied tasks,
it generates high-level actions that guide the controller. 2) BUTLER::VISION: a state estimator that translates, at each time step, the visual frame vt from the embodied world into a textual observation ot using a pre-trained Mask R-CNN detector. The generated observation ot, the initial observation o0, and the task goal g are used by the text agent the to predict the next high-level action at. 3) BUTLER::BODY: a controller that translates the high-level text action at into a sequence of one or more low-level embodied actions.

3.1 BUTLER::BRAIN (TEXT AGENT) ‚à∂ o0, ot, g ‚Üí at

BUTLER::BRAIN is a novel text-based game ùëî

‚Ñéùë°‚àí1

agent that generates high-level text actions in a token-by-token fashion akin to Natural Lan- ùëúùë°

Observation Queue

Encoder

Aggregator

Decoder

ùëéùë°

guage Generation (NLG) approaches for dia- ùëú0

logue (Sharma et al., 2017) and summarization

‚Ñéùë°

(Gehrmann et al., 2018). An overview of the agent‚Äôs architecture is shown in Figure 3. At game step t, the encoder takes the initial text observation o0, current observation ot, and the goal

Figure 3: BUTLER::BRAIN: The text agent takes
the initial/current observations o0/ot, and goal g to generate a textual action at token-by-token.

description g as input and generates a context-

aware representation of the current observable game state. The observation o0 explicitly lists all

the navigable receptacles in the scene, and goal g is sampled from a set of language templates (see

Appendix H). Since the games are partially observable, the agent only has access to the observation

describing the effects of its previous action and its present location. Therefore, we incorporate two

memory mechanisms to imbue the agent with history: (1) a recurrent aggregator, adapted from Yuan

et al. (2018), combines the encoded state with recurrent state ht‚àí1 from the previous game step; (2) an

observation queue feeds in the k most recent, unique textual observations. The decoder generates an

action sentence at token-by-token to interact with the game. The encoder and decoder are based on a

Transformer Seq2Seq model with pointer softmax mechanism (Gulcehre et al., 2016). We leverage

pre-trained BERT embeddings (Sanh et al., 2019), and tie output embeddings with input embeddings

(Press and Wolf, 2016). The agent is trained in an imitation learning setting with DAgger (Ross et al.,

2011) using expert demonstrations. See Appendix A for complete details.

When solving a task, an agent might get stuck at certain states due to various failures (e.g., action is grammatically incorrect, wrong object name). The observation for a failed action does not contain any useful feedback, so a fully deterministic actor tends to repeatedly produce the same incorrect action. To address this problem, during evaluation in both TextWorld and ALFRED, BUTLER::BRAIN uses Beam Search (Reddy et al., 1977) to generate alternative action sentences in the event of a failed action. But otherwise greedily picks a sequence of best words for efÔ¨Åciency. Note that Beam Search is not used to optimize over embodied interactions like prior work (Wang et al., 2019). but rather to simply improve the generated action sentence during failures.

3.2 BUTLER::VISION (STATE ESTIMATOR) ‚à∂ vt ‚Üí ot
At test time, agents in the embodied world must operate purely from visual input. To this end, BUTLER::VISION‚Äôs language state estimator functions as a captioning module that translates visual observations vt into textual descriptions ot. SpeciÔ¨Åcally, we use a pre-trained Mask R-CNN detec-

4

Published as a conference paper at ICLR 2021
tor (He et al., 2017) to identify objects in the visual frame. The detector is trained separately in a supervised setting with random frames from ALFRED training scenes (see Appendix D). For each frame vt, the detector generates N detections {(c1, m1), (c2, m2), . . . , (cN , mN )}, where cn is the predicted object class, and mn is a pixel-wise object mask. These detections are formatted into a sentence using a template e.g., On table 1, you see a mug 1, a tomato 1, and a tomato 2. To handle multiple instances of objects, each object is associated with a class cn and a number ID e.g., tomato 1. Commands goto, open, and examine generate a list of detections, whereas all other commands generate afÔ¨Årmative responses if the action succeeds e.g., at: put mug 1 on desk 2 ‚Üí ot+1: You put mug 1 on desk 2, otherwise produce Nothing happens to indicate failures or no state-change. See Appendix G for a full list of templates. While this work presents preliminary results with template-based descriptions, future work could generate more descriptive observations using pre-trained image-captioning models (Johnson et al., 2016), video-action captioning frameworks (Sun et al., 2019), or scene-graph parsers (Tang et al., 2020).
3.3 BUTLER::BODY (CONTROLLER) ‚à∂ vt, at ‚Üí {aÀÜ1, aÀÜ2, . . . , aÀÜL}
The controller translates a high-level text action at into a sequence of L low-level physical actions {aÀÜ1, aÀÜ2, . . . , aÀÜL} that are executable in the embodied environment. The controller handles two types of commands: manipulation and navigation. For manipulation actions, we use the ALFRED API to interact with the simulator by providing an API action and a pixel-wise mask based on Mask R-CNN detections mn that was produced during state-estimation. For navigation commands, each episode is initialized with a pre-built grid-map of the scene, where each receptacle instance is associated with a receptacle class and an interaction viewpoint (x, y, Œ∏, œÜ) with x and y representing the 2D position, Œ∏ and œÜ representing the agent‚Äôs yaw rotation and camera tilt. The goto command invokes an A* planner to Ô¨Ånd the shortest path between two viewpoints. The planner outputs a sequence of L displacements in terms of motion primitives: MOVEAHEAD, ROTATERIGHT, ROTATELEFT, LOOKUP, and LOOKDOWN, which are executed in an open-loop fashion via the ALFRED API. We note that a given pre-built grid-map of receptacle locations is a strong prior assumption, but future work could incorporate existing models from the vision-language navigation literature (Anderson et al., 2018a; Wang et al., 2019) for map-free navigation.
4 EXPERIMENTS
We design experiments to answer the following questions: (1) How important is an interactive language environment versus a static corpus? (2) Do policies learnt in TextWorld transfer to embodied environments? (3) Can policies generalize to human-annotated goals? (4) Does pre-training in an abstract textual environment enable better generalization in the embodied world?
4.1 IMPORTANCE OF INTERACTIVE LANGUAGE
The Ô¨Årst question addresses our core hypothesis that training agents in interactive TextWorld environments leads to better generalization than training agents with a static linguistic corpus. To test this hypothesis, we use DAgger (Ross et al., 2011) to train the BUTLER::BRAIN agent in TextWorld and compare it against Seq2Seq, an identical agent trained with Behavior Cloning from an equivalentlysized corpus of expert demonstrations. The demonstrations come from the same expert policies and we control the number of episodes to ensure a fair comparison. Table 2 presents results for agents trained in TextWorld and subsequently evaluated in embodied environments in a zero-shot manner. The agents are trained independently on individual tasks and also jointly on all six task types. For each task category, we select the agent with best evaluation performance in TextWorld (from 8 random seeds); this is done separately for each split: seen and unseen. These best-performing agents are then evaluated on the heldout seen and unseen embodied ALFRED tasks. For embodied evaluations, we also report goal-condition success rates, a metric proposed in ALFRED (Shridhar et al., 2020) to measure partial goal completion.3
3For instance, the task ‚Äúput a hot potato on the countertop‚Äù is composed of three goal-conditions: (1) heating some object, (2) putting a potato on the countertop, (3) heating a potato and putting it on the countertop. If the agent manages to put any potato on the countertop, then 1/3 = 0.33 goal-conditions are satisÔ¨Åed, and so on.
5

Published as a conference paper at ICLR 2021

task-type Pick & Place Examine in Light Clean & Place Heat & Place Cool & Place Pick Two & Place All Tasks

TextWorld

seen unseen

69

50

69

39

67

74

88

83

76

91

54

65

40

35

Seq2Seq seen unseen 28 (28) 17 (17) 5 (13) 0 (6) 32 (41) 12 (31) 10 (29) 12 (33) 2 (19) 21 (34) 12 (23) 0 (26) 6 (15) 5 (14)

BUTLER seen unseen 30 (30) 24 (24) 10 (26) 0 (15) 32 (46) 22 (39) 17 (38) 16 (39) 5 (21) 19 (33) 15 (33) 8 (30) 19 (31) 10 (20)

BUTLER-ORACLE

seen

unseen

53 (53) 31 (31)

22 (41) 12 (37)

44 (57) 41 (56)

60 (66) 60 (72)

41 (49) 27 (44)

32 (42) 29 (44)

37 (46) 26 (37)

Human Goals seen unseen 20 (20) 10 (10) 2 (9) 0 (8) 18 (31) 22 (39) 8 (29) 5 (30) 7 (26) 17 (34) 6 (16) 0 (6) 8 (17) 3 (12)

Table 2: Zero-shot Domain Transfer. Left: Success percentages of the best BUTLER::BRAIN agents evaluated purely in TextWorld. Mid-Left: Success percentages after zero-shot transfer to embodied environments. Mid-Right: Success percentages of BUTLER with an oracle state-estimator and controller, an upper-bound. Right: Success percentages of BUTLER with human-annotated goal descriptions, an additional source of generalization difÔ¨Åculty. All successes are averaged across three evaluation runs. Goal-condition success rates (Shridhar et al., 2020) are given in parentheses. The Seq2Seq baseline is trained in TextWorld from pre-recorded expert demonstrations using standard supervised learning. BUTLER is our main model using the Mask R-CNN detector and A* navigator. BUTLER-ORACLE uses an oracle state-estimator with ground-truth object detections and an oracle controller that directly teleports between locations.

Comparing BUTLER to Seq2Seq, we see improved performance on all types of seen tasks and Ô¨Åve of the seven types of unseen tasks, supporting the hypothesis that interactive TextWorld training is a key component in generalizing to unseen embodied tasks. Interactive language not only allows agents to explore and build an understanding of successful action patterns, but also to recover from mistakes. Through trial-and-error the BUTLER agent learns task-guided heuristics, e.g., searching all the drawers in kitchen to look for a knife. As Table 2 shows, these heuristics are subsequently more capable of generalizing to the embodied world. More details on TextWorld training and generalization performance can be found in Section 5.1.
4.2 TRANSFERRING TO EMBODIED TASKS
Since TextWorld is an abstraction of the embodied world, transferring between modalities involves overcoming domain gaps that are present in the real world but not in TextWorld. For example, the physical size of objects and receptacles must be respected ‚Äì while TextWorld will allow certain objects to be placed inside any receptacle, in the embodied world it might be impossible to put a larger object into a small receptacle (e.g. a large pot into a microwave).
Subsequently, a TextWorld-trained agent‚Äôs ability to solve embodied tasks is hindered by these domain gaps. So to study the transferability of the text agent in isolation, we introduce BUTLER-ORACLE in Table 2, an oracle variant of BUTLER which uses perfect state-estimation, object-detection, and navigation. Despite these advantages, we nevertheless observe a notable drop in performance from TextWorld to BUTLER-ORACLE. This performance gap results from the domain gaps described above as well as misdetections from Mask R-CNN and navigation failures caused by collisions. Future work might address this issue by reducing the domain gap between the two environments, or performing additional Ô¨Åne-tuning in the embodied setting.
The supplementary video contains qualitative examples of the BUTLER agent solving tasks in unseen environments. It showcases 3 successes and 1 failure of a TextWorld-only agent trained on All Tasks. In ‚Äúput a watch in the safe‚Äù, the agent has never seen the ‚Äòwatch‚Äô-‚Äòsafe‚Äô combination as a goal.
4.3 GENERALIZING TO HUMAN-ANNOTATED GOALS
BUTLER is trained with templated language, but in realistic scenarios, goals are often posed with open-ended natural language. In Table 2, we present Human Goals results of BUTLER evaluated on human-annotated ALFRED goals, which contain 66 unseen verbs (e.g., ‚Äòwash‚Äô, ‚Äògrab‚Äô, ‚Äòchill‚Äô) and 189 unseen nouns (e.g., ‚Äòrag‚Äô, ‚Äòlotion‚Äô, ‚Äòdisc‚Äô; see Appendix H for full list). Surprisingly, we Ô¨Ånd non-trivial goal-completion rate indicating that certain categories of task, such as pick and place, are quite generalizable to human language. While these preliminary results with natural language are encouraging, we expect future work could augment the templated language with synthetic-to-real transfer methods (Marzoev et al., 2020) for better generalization.

6

Published as a conference paper at ICLR 2021

4.4 TO PRETRAIN OR NOT TO PRETRAIN IN TEXTWORLD?

Given the domain gap between TextWorld and the embodied world, Why not eliminate this gap by training from scratch in the

Training Strategy
EMBODIED-ONLY TW-ONLY

train (succ %)
21.6 23.1

seen (succ %)
33.6 27.1

unseen (succ %)
23.1 34.3

train speed (eps/s) 0.9 6.1

embodied world? To answer this question, HYBRID

11.9

21.4

23.1

0.7

we investigate three training strategies: (i) EMBODIED-ONLY: pure embodied training, (ii) TW-ONLY: pure TextWorld training followed by zero-shot embodied transfer and

Table 3: Training Strategy Success. Trained on All Tasks for 50K episodes and evaluated in embodied scenes using an oracle state-estimator and controller.

(iii) HYBRID training that switches between the two environments with 75% probability for TextWorld

and 25% for embodied world. Table 3 presents success rates for these agents trained and evaluated

on All Tasks. All evaluations were conducted with an oracle state-estimator and controller. For a

fair comparison, each agent is trained for 50K episodes and the training speed is recorded for each

strategy. We report peak performance for each split.

Results indicate that TW-ONLY generalizes better to unseen environments while EMBODIED-ONLY quickly overÔ¨Åts to seen environments (even with a perfect object detector and teleport navigator). We hypothesize that the abstract TextWorld environment allows the agent to focus on quickly learning tasks without having to deal execution-failures and expert-failures caused by physical constraints inherent to embodied environments. TextWorld training is also 7√ó faster4 since it does not require running a rendering or physics engine like in the embodied setting. See Section F for more quantitative evaluations on the beneÔ¨Åts of training in TextWorld.

5 ABLATIONS
We conduct ablation studies to further investigate: (1) The generalization performance of BUTLER::BRAIN within TextWorld environments, (2) The ability of unimodal agents to learn directly through visual observations or action history, (3) The importance of various hyper-parameters and modeling choices for the performance of BUTLER::BRAIN.

5.1 GENERALIZATION WITHIN TEXTWORLD
We train and evaluate BUTLER::BRAIN in abstract TextWorld environments spanning the six tasks in Table 1, as well as All Tasks. Similar to the zero-shot results presented in Section 4.1, the All Tasks setting shows the extent to which a single policy can learn and generalize on the large set of 3,553 different tasks, but here without having to deal with failures from embodied execution.
We Ô¨Årst experimented with training BUTLER::BRAIN through reinforcement learning (RL) where the agent is rewarded after completing a goal. Due to the infesibility of using candidate commands or command templates as discussed in Section I, the RL agent had to generate actions token-by-token. Since the probability of randomly stumbling upon a grammatically correct and contextually valid action is very low (7.02e-44 for sequence length 10), the RL agent struggled to make any meaningful progress towards the tasks.
After concluding that current reinforcement learning approaches were not successful on our set of training tasks, we turned to DAgger (Ross et al., 2011) assisted by a rule-based expert (detailed in Appendix E). BUTLER::BRAIN is trained for 100K episodes using data collected by interacting with the set of training games.
Results in Table 4 show (i) Training success rate varies from 16-60% depending on the category of tasks, illustrating the challenge of solving hundreds to thousands of training tasks within each category. (ii) Transferring from training to heldout test games typically reduces performance, with the unseen rooms leading to the largest performance drops. Notable exceptions include heat and cool tasks where unseen performance exceeds training performance. (iii) Beam search is a key contributor to test performance; its ablation causes a performance drop of 21% on the seen split of All Tasks. (iv) Further ablating the DAgger strategy and directly training a Sequence-to-Sequence (Seq2Seq) model
4For a fair comparison, all agents in Table 3 use a batch-size of 10. THOR instances use 100MB√óbatch-size of GPU memory for rendering, whereas TextWorld instances are CPU-only and are thus much easier to scale up.

7

Published as a conference paper at ICLR 2021

BUTLER BUTLERg Seq2Seq

Pick & Place
tn sn un 54 61 46 54 43 33 31 26 8

Examine in Light
tn sn un 59 39 22 59 31 17 44 31 11

Clean & Place
tn sn un 37 44 39 37 30 26 34 30 42

Heat & Place tn sn un 60 81 74 60 69 70 36 50 30

Cool & Place tn sn un 46 60 100 46 50 76 27 32 33

Pick Two & Place
tn sn un 27 29 24 27 38 12 17 8 6

All Tasks
tn sn un 16 40 37 16 19 22
9 10 9

Table 4: Generalization within TextWorld environments: We independently train BUTLER::BRAIN on each type of TextWorld task and evaluate on heldout scenes of the same type. Respectively, tn/sn/un indicate success rate on train/seen/unseen tasks. All sn and un scores are computed using the random seeds (from 8 in total) producing the best Ô¨Ånal training score on each task type. BUTLER is trained with DAgger and performs beam search during evaluation. Without beam search, BUTLERg decodes actions greedily and gets stuck repeating failed actions. Further removing DAgger and training the model in a Seq2Seq fashion leads to worse generalization. Note that tn scores for BUTLER are lower than sn and un as they were computed without beam search.

with pre-recorded expert demonstrations causes a bigger performance drop of 30% on seen split of All Tasks. These results suggest that online interaction with the environment, as facilitated by DAgger learning and beam search, is essential for recovering from mistakes and sub-optimal behavior.

5.2 UNIMODAL BASELINES

Table 5 presents results for unimodal baseline comparisons to BUTLER. For all baselines, the action space and con-

Agent BUTLER

seen (succ %)
18.8

unseen (succ %)
10.1

troller are Ô¨Åxed, but the state space is substituted with differ- VISION (RESNET18)

10.0

6.0

ent modalities. To study the agents‚Äô capability of learning VISION (MCNN-FPN) 11.4

4.5

ACTION-ONLY

0.0

0.0

a single policy that generalizes across various tasks, we

train and evaluate on All Tasks. In VISION (RESNET18), Table 5: Unimodal Baselines. Trained

the textual observation from the state-estimator is replaced on All Tasks with 50K episodes and

with ResNet-18 fc7 features (He et al., 2016) from the evaluated in the embodied environment.

visual frame. Similarly, VISION (MCNN-FPN) uses the

pre-trained Mask R-CNN from the state-estimator to extract FPN layer features for the whole image.

ACTION-ONLY acts without any visual or textual feedback. We report peak performance for each

split.

The visual models tend to overÔ¨Åt to seen environments and generalize poorly to unfamiliar environments. Operating in text-space allows better transfer of policies without needing to learn state representations that are robust to visually diverse environments. The zero-performing ACTION-ONLY baseline indicates that memorizing action sequences is an infeasible strategy for agents.

5.3 MODEL ABLATIONS
Figure 4 illustrates more factors that affect the performance of BUTLER::BRAIN. The

75 #Observation
50

Init Obs

Recurrency #Train Data

train

three rows of plots show training curves, 25 evaluation curves in seen and unseen set- 0 tings, respectively. All experiments were 75 trained and evaluated on All Tasks with 8 50

unseen seen

random seeds.

25

In the Ô¨Årst column, we show the effect of 750

=0

false

true

2^2

using different observation queue lengths 50

=1 =3

true

false

2^4

2^6

ksizaes 0derescferirbsetdo innotSpecrotivoindi3n.g1,aniny wobhsicehr- 25 =5 2al^l 8

vation information to the agent. In the 0

second column, we examine the effect of explicitly keeping the initial observation o0, which lists all the receptacles in the

Figure 4: Model ablations on All Tasks. x-axis: 0 to 50k episodes; y-axis: normalized success from 0 to 75%.

scene. Keeping the initial observation o0 facilitates the decoder to generate receptacle words more

accurately for unseen tasks, but may be unnecessary in seen environments. The third column sug-

gests that the recurrent component in our aggregator is helpful in making history-based decisions

8

Published as a conference paper at ICLR 2021
particularly in seen environments where keeping track of object locations is useful. Finally, in the fourth column, we see that using more training games can lead to better generalizability in both seen and unseen settings. Fewer training games achieve high training scores by quickly overÔ¨Åtting, which lead to zero evaluation scores.
6 RELATED WORK
The longstanding goal of grounding language learning in embodied settings (Bisk et al., 2020) has lead to substantial work on interactive environments. ALFWorld extends that work with fully-interactive aligned environments that parallel textual interactions with photo-realistic renderings and physical interactions.
Interactive Text-Only Environments: We build on the work of text-based environments like TextWorld (C√¥t√© et al., 2018) and Jericho (Hausknecht et al., 2020). While these environment allow for textual interactions, they are not grounded in visual or physical modalities.
Vision and language: While substantial work exists on vision-language representation learning e.g., MAttNet (Yu et al., 2018b), CMN (Hu et al., 2017), VQA (Antol et al., 2015), CLEVR (Johnson et al., 2017), ViLBERT (Lu et al., 2019), they lack embodied or sequential decision making.
Embodied Language Learning: To address language learning in embodied domains, a number of interactive environments have been proposed: BabyAI (Chevalier-Boisvert et al., 2019), Room2Room (Anderson et al., 2018b), ALFRED (Shridhar et al., 2020), InteractiveQA (Gordon et al., 2018), EmbodiedQA (Das et al., 2018), and NetHack (K√ºttler et al., 2020). These environments use language to communicate instructions, goals, or queries to the agent, but not as a fully-interactive textual modality.
Language for State and Action Representation: Others have used language for more than just goal-speciÔ¨Åcation. Schwartz et al. (2019) use language as an intermediate state to learn policies in VizDoom. Similarly, Narasimhan et al. (2018) and Zhong et al. (2020) use language as an intermediate representation to transfer policies across different environments. Hu et al. (2019) use a natural language instructor to command a low-level executor, and Jiang et al. (2019) use language as an abstraction for hierarchical RL. However these works do not feature an interactive text environment for pre-training the agent in an abstract textual space. Zhu et al. (2017) use high-level commands similar to ALFWorld to solve tasks in THOR with IL and RL-Ô¨Ånetuning methods, but the policy only generalizes to a small set of tasks due to the vision-based state representation. Using symbolic representations for state and action is also an inherent characteristic of works in task-and-motionplanning (Kaelbling and Lozano-P√©rez, 2011; Konidaris et al., 2018) and symbolic planning (Asai and Fukunaga, 2017).
World Models: The concept of using TextWorld as a ‚Äúgame engine‚Äù to represent the world is broadly related to inverse graphics (Kulkarni et al., 2015) and inverse dynamics (Wu et al., 2017) where abstract visual or physical models are used for reasoning and future predictions. Similarly, some results in cognitive science suggest that humans use language as a cheaper alternative to sensorimotor simulation (Banks et al., 2020; Dove, 2014).
7 CONCLUSION
We introduced ALFWorld, the Ô¨Årst interactive text environment with aligned embodied worlds. ALFWorld allows agents to explore, interact, and learn abstract polices in a textual environment. Pre-training our novel BUTLER agent in TextWorld, we show zero-shot generalization to embodied tasks in the ALFRED dataset. The results indicate that reasoning in textual space allows for better generalization to unseen tasks and also faster training, compared to other modalities like vision.
BUTLER is designed with modular components which can be upgraded in future work. Examples include the template-based state-estimator and the A* navigator which could be replaced with learned modules, enabling end-to-end training of the full pipeline. Another avenue of future work is to learn ‚Äútextual dynamics models‚Äù through environment interactions, akin to vision-based world models (Ha and Schmidhuber, 2018). Such models would facilitate construction of text-engines for new domains, without requiring access to symbolic state descriptions like PDDL. Overall, we are excited by the challenges posed by aligned text and embodied environments for better cross-modal learning.
9

Published as a conference paper at ICLR 2021
ACKNOWLEDGMENTS
The authors thank Cheng Zhang, Jesse Thomason, Karthik Desingh, Rishabh Joshi, Romain Laroche, Shunyu Yao, and Victor Zhong for insightful feedback and discussions. This work was done during Mohit Shridhar‚Äôs internship at Microsoft Research.
REFERENCES
Adhikari, A., Yuan, X., C√¥t√©, M.-A., Zelinka, M., Rondeau, M.-A., Laroche, R., Poupart, P., Tang, J., Trischler, A., and Hamilton, W. L. (2020). Learning dynamic belief graphs to generalize on text-based games. In Neural Information Processing Systems (NeurIPS).
Ammanabrolu, P. and Hausknecht, M. (2020). Graph constrained reinforcement learning for natural language action spaces. In International Conference on Learning Representations.
Anderson, P., Wu, Q., Teney, D., Bruce, J., Johnson, M., S√ºnderhauf, N., Reid, I., Gould, S., and van den Hengel, A. (2018a). Vision-and-language navigation: Interpreting visually-grounded navigation instructions in real environments. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition.
Anderson, P., Wu, Q., Teney, D., Bruce, J., Johnson, M., S√ºnderhauf, N., Reid, I., Gould, S., and van den Hengel, A. (2018b). Vision-and-Language Navigation: Interpreting visually-grounded navigation instructions in real environments. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR).
Antol, S., Agrawal, A., Lu, J., Mitchell, M., Batra, D., Zitnick, C. L., and Parikh, D. (2015). VQA: Visual Question Answering. In International Conference on Computer Vision (ICCV).
Asai, M. and Fukunaga, A. (2017). Classical planning in deep latent space: Bridging the subsymbolicsymbolic boundary. arXiv preprint arXiv:1705.00154.
Ba, L. J., Kiros, J. R., and Hinton, G. E. (2016). Layer normalization. CoRR, abs/1607.06450.
Banks, B., WingÔ¨Åeld, C., and Connell, L. (2020). Linguistic distributional knowledge and sensorimotor grounding both contribute to semantic category production.
Bisk, Y., Holtzman, A., Thomason, J., Andreas, J., Bengio, Y., Chai, J., Lapata, M., Lazaridou, A., May, J., Nisnevich, A., Pinto, N., and Turian, J. (2020). Experience Grounds Language. In Empirical Methods in Natural Language Processing.
Chevalier-Boisvert, M., Bahdanau, D., Lahlou, S., Willems, L., Saharia, C., Nguyen, T. H., and Bengio, Y. (2019). BabyAI: First steps towards grounded language learning with a human in the loop. In International Conference on Learning Representations.
Cho, K., van Merri√´nboer, B., Gulcehre, C., Bahdanau, D., Bougares, F., Schwenk, H., and Bengio, Y. (2014). Learning phrase representations using RNN encoder‚Äìdecoder for statistical machine translation. In Proceedings of the 2014 Conference on Empirical Methods in Natural Language Processing (EMNLP).
C√¥t√©, M.-A., K√°d√°r, A., Yuan, X., Kybartas, B., Barnes, T., Fine, E., Moore, J., Tao, R. Y., Hausknecht, M., Asri, L. E., Adada, M., Tay, W., and Trischler, A. (2018). Textworld: A learning environment for text-based games. CoRR, abs/1806.11532.
Das, A., Datta, S., Gkioxari, G., Lee, S., Parikh, D., and Batra, D. (2018). Embodied Question Answering. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR).
Dove, G. (2014). Thinking in words: language as an embodied medium of thought. Topics in cognitive science, 6(3):371‚Äì389.
Gehrmann, S., Deng, Y., and Rush, A. (2018). Bottom-up abstractive summarization. In Proceedings of the 2018 Conference on Empirical Methods in Natural Language Processing.
10

Published as a conference paper at ICLR 2021
Gordon, D., Kembhavi, A., Rastegari, M., Redmon, J., Fox, D., and Farhadi, A. (2018). Iqa: Visual question answering in interactive environments. In Computer Vision and Pattern Recognition (CVPR), 2018 IEEE Conference on.
Gulcehre, C., Ahn, S., Nallapati, R., Zhou, B., and Bengio, Y. (2016). Pointing the unknown words. In Proceedings of the 54th Annual Meeting of the Association for Computational Linguistics (Volume 1: Long Papers).
Ha, D. and Schmidhuber, J. (2018). Recurrent world models facilitate policy evolution. In Advances in Neural Information Processing Systems 31.
Hausknecht, M. and Stone, P. (2015). Deep recurrent q-learning for partially observable mdps. arXiv preprint arXiv:1507.06527.
Hausknecht, M. J., Ammanabrolu, P., C√¥t√©, M.-A., and Yuan, X. (2020). Interactive Ô¨Åction games: A colossal adventure. In AAAI.
He, K., Gkioxari, G., Doll√°r, P., and Girshick, R. (2017). Mask r-cnn. In Proceedings of the IEEE international conference on computer vision.
He, K., Zhang, X., Ren, S., and Sun, J. (2016). Deep residual learning for image recognition. In Proceedings of the IEEE conference on computer vision and pattern recognition.
Helmert, M. (2006). The Fast Downward planning system. Journal of ArtiÔ¨Åcial Intelligence Research.
Hu, H., Yarats, D., Gong, Q., Tian, Y., and Lewis, M. (2019). Hierarchical decision making by generating and following natural language instructions. In Advances in Neural Information Processing Systems.
Hu, R., Rohrbach, M., Andreas, J., Darrell, T., and Saenko, K. (2017). Modeling relationships in referential expressions with compositional modular networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition.
Jiang, Y., Gu, S. S., Murphy, K. P., and Finn, C. (2019). Language as an abstraction for hierarchical deep reinforcement learning. In Advances in Neural Information Processing Systems.
Johnson, J., Hariharan, B., van der Maaten, L., Fei-Fei, L., Zitnick, C. L., and Girshick, R. (2017). Clevr: A diagnostic dataset for compositional language and elementary visual reasoning. In CVPR.
Johnson, J., Karpathy, A., and Fei-Fei, L. (2016). Densecap: Fully convolutional localization networks for dense captioning. In Proceedings of the IEEE conference on computer vision and pattern recognition.
Kaelbling, L. P. and Lozano-P√©rez, T. (2011). Hierarchical task and motion planning in the now. In 2011 IEEE International Conference on Robotics and Automation, pages 1470‚Äì1477. IEEE.
Kingma, D. P. and Ba, J. (2014). Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980.
Kolve, E., Mottaghi, R., Han, W., VanderBilt, E., Weihs, L., Herrasti, A., Gordon, D., Zhu, Y., Gupta, A., and Farhadi, A. (2017). Ai2-thor: An interactive 3d environment for visual ai. arXiv preprint arXiv:1712.05474.
Konidaris, G., Kaelbling, L. P., and Lozano-Perez, T. (2018). From skills to symbols: Learning symbolic representations for abstract high-level planning. Journal of ArtiÔ¨Åcial Intelligence Research, 61:215‚Äì289.
Kulkarni, T. D., Whitney, W. F., Kohli, P., and Tenenbaum, J. (2015). Deep convolutional inverse graphics network. In Advances in neural information processing systems.
K√ºttler, H., Nardelli, N., Miller, A. H., Raileanu, R., Selvatici, M., Grefenstette, E., and Rockt√§schel, T. (2020). The nethack learning environment.
Lin, T.-Y., Maire, M., Belongie, S., Hays, J., Perona, P., Ramanan, D., Doll√°r, P., and Zitnick, C. L. (2014). Microsoft coco: Common objects in context. In European conference on computer vision.
11

Published as a conference paper at ICLR 2021
Lu, J., Batra, D., Parikh, D., and Lee, S. (2019). Vilbert: Pretraining task-agnostic visiolinguistic representations for vision-and-language tasks. In Advances in Neural Information Processing Systems.
MacMahon, M., Stankiewicz, B., and Kuipers, B. (2006). Walk the talk: Connecting language, knowledge, and action in route instructions. In Proceedings of the 21st National Conference on ArtiÔ¨Åcial Intelligence (AAAI-2006).
Marzoev, A., Madden, S., Kaashoek, M. F., Cafarella, M., and Andreas, J. (2020). Unnatural language processing: Bridging the gap between synthetic and natural language data. arXiv preprint arXiv:2004.13645.
McDermott, D., Ghallab, M., Howe, A., Knoblock, C., Ram, A., Veloso, M., Weld, D., and Wilkins, D. (1998). Pddl-the planning domain deÔ¨Ånition language.
Narasimhan, K., Barzilay, R., and Jaakkola, T. (2018). Grounding language for transfer in deep reinforcement learning. JAIR, 63(1):849‚Äì874.
Press, O. and Wolf, L. (2016). Using the output embedding to improve language models. arXiv preprint arXiv:1608.05859.
Reddy, D. R. et al. (1977). Speech understanding systems: A summary of results of the Ô¨Åve-year research effort. Department of Computer Science. Camegie-Mell University, Pittsburgh, PA, 17.
Ross, S., Gordon, G., and Bagnell, D. (2011). A reduction of imitation learning and structured prediction to no-regret online learning. In Proceedings of the fourteenth international conference on artiÔ¨Åcial intelligence and statistics.
Sanh, V., Debut, L., Chaumond, J., and Wolf, T. (2019). Distilbert, a distilled version of bert: smaller, faster, cheaper and lighter. arXiv preprint arXiv:1910.01108.
Schwartz, E., Tennenholtz, G., Tessler, C., and Mannor, S. (2019). Language is power: Representing states using natural language in reinforcement learning.
Sharma, S., Asri, L. E., Schulz, H., and Zumer, J. (2017). Relevance of unsupervised metrics in taskoriented dialogue for evaluating natural language generation. arXiv preprint arXiv:1706.09799.
Shridhar, M., Thomason, J., Gordon, D., Bisk, Y., Han, W., Mottaghi, R., Zettlemoyer, L., and Fox, D. (2020). Alfred: A benchmark for interpreting grounded instructions for everyday tasks. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition, pages 10740‚Äì10749.
Sun, C., Myers, A., Vondrick, C., Murphy, K., and Schmid, C. (2019). Videobert: A joint model for video and language representation learning. In Proceedings of the IEEE International Conference on Computer Vision.
Tang, K., Niu, Y., Huang, J., Shi, J., and Zhang, H. (2020). Unbiased scene graph generation from biased training. In Proceedings of the IEEE/CVF Conference on Computer Vision and Pattern Recognition.
Todorov, E., Erez, T., and Tassa, Y. (2012). Mujoco: A physics engine for model-based control. In 2012 IEEE/RSJ International Conference on Intelligent Robots and Systems.
Vaswani, A., Shazeer, N., Parmar, N., Uszkoreit, J., Jones, L., Gomez, A. N., Kaiser, L. u., and Polosukhin, I. (2017). Attention is all you need. In Advances in Neural Information Processing Systems 30.
Wang, X., Huang, Q., Celikyilmaz, A., Gao, J., Shen, D., Wang, Y.-F., Wang, W. Y., and Zhang, L. (2019). Reinforced cross-modal matching and self-supervised imitation learning for visionlanguage navigation. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition.
Wu, J., Lu, E., Kohli, P., Freeman, B., and Tenenbaum, J. (2017). Learning to see physics via visual de-animation. In Advances in Neural Information Processing Systems.
12

Published as a conference paper at ICLR 2021 Yu, A. W., Dohan, D., Le, Q., Luong, T., Zhao, R., and Chen, K. (2018a). Fast and accurate reading
comprehension by combining self-attention and convolution. In International Conference on Learning Representations. Yu, L., Lin, Z., Shen, X., Yang, J., Lu, X., Bansal, M., and Berg, T. L. (2018b). Mattnet: Modular attention network for referring expression comprehension. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition. Yuan, X., C√¥t√©, M.-A., Sordoni, A., Laroche, R., Combes, R. T. d., Hausknecht, M., and Trischler, A. (2018). Counting to explore and generalize in text-based games. arXiv preprint arXiv:1806.11525. Zhong, V., Rockt√§schel, T., and Grefenstette, E. (2020). RTFM: Generalising to novel environment dynamics via reading. In ICLR. Zhu, Y., Gordon, D., Kolve, E., Fox, D., Fei-Fei, L., Gupta, A., Mottaghi, R., and Farhadi, A. (2017). Visual semantic planning using deep successor representations. In IEEE International Conference on Computer Vision, ICCV 2017, Venice, Italy, October 22-29, 2017.
13

Published as a conference paper at ICLR 2021

A DETAILS OF BUTLER::BRAIN
In this section, we use ot to denote text observation at game step t, g to denote the goal description provided by a game. We use L to refer to a linear transformation and Lf means it is followed by a non-linear activation function f . Brackets [‚ãÖ; ‚ãÖ] denote vector concatenation, ‚äô denotes element-wise multiplication.

A.1 OBSERVATION QUEUE
As mentioned in Section 3.1, we utilize an observation queue to cache the text observations that have been seen recently. Since the initial observation o0 describes the high level layout of a room, including receptacles present in the current game, we it visible to BUTLER::BRAIN at all game steps, regardless of the length of the observation queue. SpeciÔ¨Åcally, the observation queue has an extra space storing o0, at any game step, we Ô¨Årst concatenate all cached observations in the queue, then prepend the o0 to form the input to the encoder. We Ô¨Ånd this helpful because it facilitates the pointer softmax mechanism in the decoder (described below) by guiding it to point to receptacle words in the observation. An ablation study on this is provided in Section 5.

A.2 ENCODER
We use a transformer-based encoder, which consists of an embedding layer and a transformer block (Vaswani et al., 2017). SpeciÔ¨Åcally, embeddings are initialized by pre-trained 768-dimensional BERT embeddings (Sanh et al., 2019). The embeddings are Ô¨Åxed during training in all settings.
The transformer block consists of a stack of 5 convolutional layers, a self-attention layer, and a 2-layer MLP with a ReLU non-linear activation function in between. In the block, each convolutional layer has 64 Ô¨Ålters, each kernel‚Äôs size is 5. In the self-attention layer, we use a block hidden size H of 64, as well as a single head attention mechanism. Layernorm (Ba et al., 2016) is applied after each component inside the block. Following standard transformer training, we add positional encodings into each block‚Äôs input.
At every game step t, we use the same encoder to process text observation ot and goal description g. The resulting representations are hot ‚àà RLot √óH and hg ‚àà RLg√óH , where Lot is the number of tokens in ot, Lg denotes the number of tokens in g, H = 64 is the hidden size.

A.3 AGGREGATOR

We adopt the context-query attention mechanism from the question answering literature (Yu et al., 2018a) to aggregate the two representations hot and hg.
SpeciÔ¨Åcally, a tri-linear similarity function is used to compute the similarity between each token in hot with each token in hg. The similarity between i-th token in ho and j-th token in hg is thus computed by (omitting game step t for simplicity):

Sim(i, j) = W (hoi , hgj , hoi ‚äô hgj ), (1)

where W is a trainable parameter in the tri-linear function. By applying the above computation for each ho and hg pair, we get a similarity matrix S ‚àà RLo√óLg .

By computing the softmax of the similarity matrix S along both dimensions (number of tokens in goal description Lg and number of tokens in observation Lo), we get Sg and So, respectively. The two representations are then aggregated by:

hog = [ho; P ; ho ‚äô P ; ho ‚äô Q],

P = Sgh‚ä§g ,

(2)

Q = SgSo‚ä§h‚ä§o ,

where

hog

‚àà

Lo √ó4H
R

is

the

aggregated

observation

representation.

14

Published as a conference paper at ICLR 2021

Next, a linear transformation projects the aggregated representations to a space with size H = 64:

hog = Ltanh(hog).

(3)

To incorporate history, we use a recurrent neural network. SpeciÔ¨Åcally, we use a GRU (Cho et al., 2014):
hRNN = Mean(hog), ht = GRU(hRNN, ht‚àí1), (4)
in which, the mean pooling is performed along the dimension of number of tokens, i.e., hRNN ‚àà RH . ht‚àí1 is the output of the GRU cell at game step t ‚àí 1.

A.4 DECODER

Our decoder consists of an embedding layer, a transformer block and a pointer softmax mechanism
(Gulcehre et al., 2016). We Ô¨Årst obtain the source representation by concatenating hog and ht, resulting hsrc ‚àà RLo√ó2H .

Similar to the encoder, the embedding layer is frozen after initializing it with pre-trained BERT

embeddings. The transformer block consists of two attention layers and a 3-layer MLP with ReLU

non-linear activation functions inbetween. The Ô¨Årst attention layer computes the self attention of the

input embeddings hself as a contextual encoding for the target tokens. The second attention layer

then

computes

the

attention

Œ±sirc

‚àà

Lo
R

between

the

source

representation

hsrc

and

the

i-th

token

in

hself. The i-th target token is consequently represented by the weighted sum of hsrc, with the weights Œ±sirc. This generates a source information-aware target representation h‚Ä≤tgt ‚àà RLtgt√óH , where Ltgt

denotes the number of tokens in the target sequence. Next, h‚Ä≤tgt is fed into the 3-layer MLP with ReLU

activation functions inbetween, resulting htgt ‚àà RLtgt√óH . The block hidden size of this transformer is

H = 64.

Taking htgt as input, a linear layer with tanh activation projects the target representation into the same space as the embeddings (with dimensionality of 768), then the pre-trained embedding matrix E

generates output logits (Press and Wolf, 2016), where the output size is same as the vocabulary size.

The resulting logits are then normalized by a softmax to generate a probability distribution over all

tokens in vocabulary:

pa(yi) = ESoftmax(Ltanh(htgt)),

(5)

in which, pa(yi) is the generation (abstractive) probability distribution.

We employ the pointer softmax (Gulcehre et al., 2016) mechanism to switch between generating a token yi (from a vocabulary) and pointing (to a token in the source text). SpeciÔ¨Åcally, the pointer softmax module computes a scalar switch si at each generation time-step i and uses it to interpolate the abstractive distribution pa(yi) over the vocabulary (Equation 5) and the extractive distribution px(yi) = Œ±sirc over the source text tokens:

p(yi) = si ‚ãÖ pa(yi) + (1 ‚àí si) ‚ãÖ px(yi),

(6)

where si is conditioned on both the attention-weighted source representation ‚àëj Œ±sir,cj ‚ãÖ hjsrc and the

decoder state hitgt:

si = Ls1igmoid(tanh(L2( Œ±sir,cj ‚ãÖ hjsrc) + L3(hitgt))).

(7)

j

In

which,

L1

‚àà

RH√ó1,

L2

‚àà

2H √óH
R

and

L3

‚àà

H √óH
R

are

linear

layers,

H

=

64.

B TRAINING AND IMPLEMENTATION DETAILS
In this section, we provide hyperparameters and other implementation details. For all experiments, we use Adam (Kingma and Ba, 2014) as the optimizer. The learning rate is set to 0.001 with a clip gradient norm of 5.

15

Published as a conference paper at ICLR 2021

During training with DAgger, we use a batch size of 10 to collect transitions (tuples of {o0, ot, g, aÀÜt}) at each game step t, where aÀÜt is the ground-truth action provided by the rule-based expert (see Section E). We gather a sequence of transitions from each game episode, and push each sequence into a replay buffer, which has a capacity of 500K episodes. We set the max number of steps per episode to be 50. If the agent uses up this budget, the game episode is forced to terminate. We linearly anneal the fraction of the expert‚Äôs assistance from 100% to 1% across a window of 50K episodes.

The agent is updated after every 5 steps of data collection. We sample a batch of 64 data points from the replay buffer. In the setting with the recurrent aggregator, every sampled data point is a sequence of 4 consecutive transitions. Following the training strategy used in the recurrent DQN literature (Hausknecht and Stone, 2015; Yuan et al., 2018), we use the Ô¨Årst 2 transitions to estimate the recurrent states, and the last 2 transitions for updating the model parameters.

BUTLER::BRAIN learns to generate actions token-by-token, where we set the max token length to be 20. The decoder stops generation either when it generates a special end-of-sentence token [EOS], or hits the token length limit.

When using the beam search heuristic to recover from failed actions (see Figure 5), we use a beam width of 10, and take the top-5 ranked outputs as candidates. We iterate through the candidates in the rank order until one of them succeeds. This heuristic is not always guaranteed to succeed, however, we Ô¨Ånd it helpful in most cases. Note that we do not employ beam search when we evaluate during the training process for efÔ¨Åciency, e.g., in the seen and unseen curves shown in Figure 4. We take the best performing checkpoints and then apply this heuristic during evaluation and report the resulting scores in tables (e.g., Table 2).

take open

2

soapbottle

1

from

countertop

4

5

cat 4

microwave 1

close

microwave

4

<s>

go to

cabinet

1

cabinet

‚Ä¶

drawer

2

Probability

Low

High

Figure 5: Beam search for recovery actions.

By default unless mentioned otherwise (ablations), we use all available training games in each of the task types. We use an observation queue length of 5 and use a recurrent aggregator. The model is trained with DAgger, and during evaluation, we apply the beam search heuristic to produce the reported scores. All experiment settings in TextWorld are run with 8 random seeds. All text agents are trained for 50,000 episodes.

C TEXTWORLD ENGINE
Internally, the TextWorld Engine is divided into two main components: a planner and text generator.
Planner TextWorld Engine uses Fast Downward (Helmert, 2006), a domain-independent classical planning system to maintain and update the current state of the game. A state is represented by a set of predicates which deÔ¨Åne the relations between the entities (objects, player, room, etc.) present in the game. A state can be modiÔ¨Åed by applying production rules corresponding to the actions listed in Table 6. All variables, predicates, and rules are deÔ¨Åned using the PDDL language.
For instance, here is a simple state representing a player standing next to a microwave which is closed and contains a mug:
st = at(player, microwave) ‚äó in(mug, microwave) ‚äó closed(microwave) ‚äó openable(microwave),
where the symbol ‚äó is the linear logic multiplicative conjunction operator. Given that state, a valid action could be open microwave, which would essentially transform the state by replacing closed(microwave) with open(microwave).
Text generator The other component of the TextWorld Engine, the text generator, uses a contextsensitive grammar designed for the ALFRED environments. The grammar consists of text templates similar to those listed in Table 6. When needed, the engine will sample a template given some context,

16

Published as a conference paper at ICLR 2021
i.e., the current state and the last action. Then, the template gets realized using the predicates found in the current state.
D MASK R-CNN DETECTOR
We use a Mask R-CNN detector (He et al., 2017) pre-trained on MSCOCO (Lin et al., 2014) and Ô¨Åne-tune it with additional labels from ALFRED training scenes. To generate additional labels, we replay the expert demonstrations from ALFRED and record ground-truth image and instance segmentation pairs from the simulator (THOR) after completing each high-level action e.g., goto, pickup etc. We generate a dataset of 50K images, and Ô¨Åne-tune the detector for 4 epochs with a batch size of 8 and a learning rate of 5e-4. The detector recognizes 73 object classes where each class could vary up to 1-10 instances. Since demonstrations in the kitchen are often longer as they involve complex sequences like heating, cleaning etc., the labels are slightly skewed towards kitchen objects. To counter this, we balance the number of images sampled from each room (kitchen, bedroom, livingroom, bathroom) so the distribution of object categories is uniform across the dataset.
E RULE-BASED EXPERT
To train text agents in an imitation learning (IL) setting, we use a rule-based expert for supervision. A given task is decomposed into sequence of subgoals (e.g., for heat & place: Ô¨Ånd the object, pick the object, Ô¨Ånd the microwave, heat the object with the microwave, Ô¨Ånd the receptacle, place the object in the receptacle), and a closed-loop controller tries to sequentially execute these goals. We note that while designing rule-based experts for ALFWorld is relatively straightforward, experts operating directly in embodied settings like the PDDL planner used in ALFRED are prone to failures due to physical infeasibilities and non-deterministic behavior in physics-based environments.
F BENEFITS OF TRAINING IN TEXTWORLD OVER EMBODIED WORLD
Pre-training in TextWorld offers several beneÔ¨Åts over directly training in embodied environments. Figure 6 presents the performance of an expert (that agents are trained to imitate) across various environments. The abstract textual space leads to higher goal success rates resulting from successful navigation and manipulation subroutines. TextWorld agents also do not suffer from object misdetections and slow execution speed.
Figure 6: Domain Analysis: The performance of an expert across various environments.
17

Published as a conference paper at ICLR 2021

G OBSERVATION TEMPLATES
The following templates are used by the state-estimator to generate textual observations ot. The object IDs {obj id} correspond to Mask R-CNN objects detection or ground-truth instance IDs. The receptacle IDs {recep id} are based on the receptacles listed in the initial observation o0. Failed actions and actions without any state-changes result in Nothing happens.

Actions goto

Templates
(a) You arrive at {loc id}. On the {recep id}, you see a {obj1 id}, ... and a {objN id}.
(b) You arrive at {loc id}. The {recep id} is closed. (c) You arrive at {loc id}. The {recep id} is open.
On it, you see a {obj1 id}, ... and a {objN id}.

take

You pick up the {obj id} from the {recep id}.

put

You put the {obj id} on the {recep id}.

open

(a) You open the {recep id}. you see a {obj1 id}, ...
(b) You open the {recep id}.

In it, and a {objN id}. The {recep id} is empty.

close

You close the {recep id}.

toggle You turn the {obj id} on.

heat

You heat the {obj id} with the {recep id}.

cool

You cool the {obj id} with the {recep id}.

clean

You clean the {obj id} with the {recep id}.

(a) You are carrying: {obj id}. inventory (b) You are not carrying anything.

examine

(a) On the {recep id}, you see a {obj1 id}, ... and a {objN id}.
(b) This is a hot/cold/clean {obj}.

Table 6: High-level text actions supported in ALFWorld along with their observation templates.

18

Published as a conference paper at ICLR 2021

H GOAL DESCRIPTIONS
H.1 TEMPLATED GOALS
The goal instructions for training games are generated with following templates. Here obj, recep, lamp refer to object, receptacle, and lamp classes, respectively, that pertain to a particular task. For each task, the two corresponding templates are sampled with equal probability.

task-type Pick & Place Examine in Light Clean & Place Heat & Place Cool & Place Pick Two & Place

Templates
(a) put a {obj} in {recep}. (b) put some {obj} on {recep}. (a) look at {obj} under the {lamp}. (b) examine the {obj} with the {lamp}. (a) put a clean {obj} in {recep}. (b) clean some {obj} and put it in {recep}. (a) put a hot {obj} in {recep}. (b) heat some {obj} and put it in {recep}. (a) put a cool {obj} in {recep}. (b) cool some {obj} and put it in {recep}. (a) put two {obj} in {recep}. (b) find two {obj} and put them {recep}.

Table 7: Task-types and the corresponding goal description templates.

H.2 HUMAN ANNOTATED GOALS
The human goal descriptions used during evaluation contain 66 unseen verbs and 189 unseen nouns with respect to the templated goal instructions used during training.
Unseen Verbs: acquire, arrange, can, carry, chill, choose, cleaning, clear, cook, cooked, cooled, dispose, done, drop, end, Ô¨Åll, Ô¨Ålled, frying, garbage, gather, go, grab, handled, heated, heating, hold, holding, inspect, knock, left, lit, lock, microwave, microwaved, move, moving, pick, picking, place, placed, placing, putting, read, relocate, remove, retrieve, return, rinse, serve, set, soak, stand, standing, store, take, taken, throw, transfer, turn, turning, use, using, walk, warm, wash, washed.
Unseen Nouns: alarm, area, back, baisin, bar, bars, base, basin, bathroom, beat, bed, bedroom, bedside, bench, bin, books, bottle, bottles, bottom, box, boxes, bureau, burner, butter, can, canteen, card, cardboard, cards, cars, cds, cell, chair, chcair, chest, chill, cistern, cleaning, clock, clocks, coffee, container, containers, control, controllers, controls, cooker, corner, couch, count, counter, cover, cream, credit, cupboard, dining, disc, discs, dishwasher, disks, dispenser, door, drawers, dresser, edge, end, Ô¨Çoor, food, foot, freezer, game, garbage, gas, glass, glasses, gold, grey, hand, head, holder, ice, inside, island, item, items, jars, keys, kitchen, knifes, knives, laddle, lamp, lap, left, lid, light, loaf, location, lotion, machine, magazine, maker, math, metal, microwaves, move, nail, newsletters, newspapers, night, nightstand, object, ottoman, oven, pans, paper, papers, pepper, phone, piece, pieces, pillows, place, polish, pot, pullout, pump, rack, rag, recycling, refrigerator, remote, remotes, right, rinse, roll, rolls, room, safe, salt, scoop, seat, sets, shaker, shakers, shelves, side, sink, sinks, skillet, soap, soaps, sofa, space, spatulas, sponge, spoon, spot, spout, spray, stand, stool, stove, supplies, table, tale, tank, television, textbooks, time, tissue, tissues, toaster, top, towel, trash, tray, tv, vanity, vases, vault, vegetable, wall, wash, washcloth, watches, water, window, wine.
I ACTION CANDIDATES VS ACTION GENERATION
BUTLER::BRAIN generates actions in a token-by-token fashion. Prior text-based agents typically use a list of candidate commands from the game engine (Adhikari et al., 2020) or populate a list of command templates (Ammanabrolu and Hausknecht, 2020). We initially trained our agents with candidate commands from the TextWorld Engine, but they quickly oveÔ¨Åt without learning affordances,
19

Published as a conference paper at ICLR 2021
commonsense, or pre-conditions, and had zero performance on embodied transfer. In the embodied setting, without access to a TextWorld Engine, it is difÔ¨Åcult to generate candidate actions unless a set of heuristics is handcrafted with strong priors and commonsense knowledge. We also experimented with populating a list of command templates, but found this to be infeasible as some scenarios involved 1000s of populated actions per game step.
J ALFRED TASK DESCRIPTIONS
The following descriptions describe the processes involved in each of six task-types: ‚Ä¢ Pick & Place (e.g., ‚Äúput a plate on the coffee table‚Äù) - the agent must Ô¨Ånd an object of the desired type, pick it up, Ô¨Ånd the correct location to place it, and put it down there. ‚Ä¢ Examine in Light (e.g., ‚Äúexamine a book under the lamp‚Äù) - the agent must Ô¨Ånd an object of the desired type, locate and turn on a light source with the desired object in-hand. ‚Ä¢ Clean & Place (e.g., ‚Äúclean the knife and put in the drawer‚Äù) - the agent must Ô¨Ånd an object of the desired type, pick it up, go to a sink or a basin, wash the object by turning on the faucet, then Ô¨Ånd the correct location to place it, and put it down there. ‚Ä¢ Heat & Place (e.g., ‚Äúheat a mug and put on the coffee table‚Äù) - the agent must Ô¨Ånd an object of the desired type, pick it up, go to a microwave, heat the object turning on the microwave, then Ô¨Ånd the correct location to place it, and put it down there. ‚Ä¢ Cool & Place (e.g., ‚Äúput a cool bottle on the countertop‚Äù) - the agent must Ô¨Ånd an object of the desired type, pick it up, go to a fridge, put the object inside the fridge and cool it, then Ô¨Ånd the correct location to place it, and put it down there. ‚Ä¢ Pick Two & Place (e.g., ‚Äúput two pencils in the drawer‚Äù) - the agent must Ô¨Ånd an object of the desired type, pick it up, Ô¨Ånd the correct location to place it, put it down there, then look for another object of the desired type, pick it up, return to previous location, and put it down there with the other object.
20

Published as a conference paper at ICLR 2021
K ALFWORLD TEXT GAME EXAMPLES
Three examples of ALFWorld text game walkthroughs:
You are in the middle of a room. Looking quickly around you, you see a towelholder 1, a toilet 1, a bathtubbasin 1, a drawer 4, a handtowelholder 2, a drawer 6, a drawer 1, a countertop 1, a sinkbasin 1, a drawer 2, a drawer 3, a toiletpaperhanger 1, a drawer 5, a handtowelholder 1, a towelholder 2, a sinkbasin 2, and a garbagecan 1.
Your task is to: put a clean cloth in bathtubbasin.
> go to drawer 5 You arrive at loc 9. The drawer 5 is closed. > open drawer 5 You open the drawer 5. The drawer 5 is open. In it, you see a candle 1. > close drawer 5 You close the drawer 5. > go to countertop 1 You arrive at loc 25. On the countertop 1, you see a cloth 2, a soapbottle 1, a cloth 1, and a candle 3. > take cloth 1 from countertop 1 You pick up the cloth 1 from the countertop 1. > go to sinkbasin 1 You arrive at loc 20. On the sinkbasin 1, you see nothing. > clean cloth 1 with sinkbasin 1 You clean the cloth 1 using the sinkbasin 1. > go to bathtubbasin 1 You arrive at loc 14. On the bathtubbasin 1, you see a soapbar 1. > put cloth 1 in/on bathtubbasin 1 You won!
You are in the middle of a room. Looking quickly around you, you see a drawer 15, a drawer 19, a drawer 7, a armchair 1, a drawer 3, a drawer 16, a drawer 2, a drawer 17, a sidetable 3, a sidetable 5, a drawer 4, a drawer 20, a sofa 1, a drawer 13, a drawer 12, a drawer 9, a drawer 21, a sidetable 4, a sidetable 2, a drawer 5, a drawer 11, a drawer 1, a garbagecan 1, a dresser 1, a cabinet 1, a drawer 8, a drawer 18, a sidetable 1, a drawer 14, a drawer 6, and a drawer 10.
Your task is to: find two remotecontrol and put them in armchair.
> go to sidetable 2 You arrive at loc 34. On the sidetable 2, you see a remotecontrol 1. > take remotecontrol 1 from sidetable 2 You pick up the remotecontrol 1 from the sidetable 2. > go to armchair 1 You arrive at loc 1. On the armchair 1, you see nothing. > put remotecontrol 1 in/on armchair 1 You put the remotecontrol 1 in/on the armchair 1. > go to dresser 1 You arrive at loc 18. On the dresser 1, you see a creditcard 1, a television 1, a laptop 1, a book 1, a statue 2, and a cellphone 2. > go to sidetable 5 You arrive at loc 17. On the sidetable 5, you see a box 1, and a creditcard 2. > go to sofa 1 You arrive at loc 2. On the sofa 1, you see a newspaper 1, a pillow 1, and a remotecontrol 2. > take remotecontrol 2 from sofa 1 You pick up the remotecontrol 2 from the sofa 1. > go to armchair 1 You arrive at loc 1. On the armchair 1, you see a remotecontrol 1. > put remotecontrol 2 in/on armchair 1 You won!
You are in the middle of a room. Looking quickly around you, you see a safe 1, a shelf 4, a drawer 2, a bed 1, a drawer 1, a shelf 5, a shelf 2, a sidetable 2, a shelf 3, a drawer 3, a shelf 1, a sidetable 1, a desk 1, and a garbagecan 1.
Your task is to: examine the alarmclock with the desklamp.
> go to desk 1 You arrive at loc 8. On the desk 1, you see a pen 1, a bowl 1, a alarmclock 2, a pencil 2, a pencil 3, a creditcard 3, a book 1, a alarmclock 3, a keychain 3, and a book 2. > take alarmclock 2 from desk 1 You pick up the alarmclock 2 from the desk 1. > go to sidetable 2 You arrive at loc 1. On the sidetable 2, you see a desklamp 1, and a alarmclock 1. > use desklamp 1 You won!
21

