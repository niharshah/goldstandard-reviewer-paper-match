Decentralized, Hybrid MAC Design with Reduced State Information Exchange for Low-Delay IoT Applications

Avi Mohanâˆ— Technion

Arpan Chattopadhyayâ€  IIT Delhi

Shivam Vinayak Vatsaâ€¡ ABB

Anurag KumarÂ§ IISc Â¶

arXiv:2105.11213v1 [cs.NI] 24 May 2021

Abstract
We consider a system of several collocated nodes sharing a time slotted wireless channel, and seek a MAC that (i) provides low mean delay, (ii) has distributed control (i.e., there is no central scheduler), and (iii) does not require explicit exchange of state information or control signals. The design of such MAC protocols must keep in mind the need for contention access at light traï¬ƒc, and scheduled access in heavy traï¬ƒc, leading to the long-standing interest in hybrid, adaptive MACs.
We ï¬rst propose EZMAC, a simple extension of an existing decentralized, hybrid MAC called ZMAC. Next, motivated by our results on delay and throughput optimality in partially observed, constrained queuing networks, we develop another decentralized MAC protocol that we term QZMAC. A method to improve the short-term fairness of QZMAC is proposed and analysed, and the resulting modiï¬ed algorithm is shown to possess better fairness properties than QZMAC. The theory developed to reduce delay is also shown to work in the presence of transmission errors and fast fading.
Extensions to handle time critical traï¬ƒc (alarms, for example) and hidden nodes are also discussed. Practical implementation issues, such as handling Clear Channel Assessment (CCA) errors, are outlined. We implement and demonstrate the performance of QZMAC on a test bed consisting of CC2420 based Crossbow telosB motes, running the 6TiSCH communication stack on the Contiki operating system over the 2.4GHz ISM band. Finally, using simulations, we show that both protocols achieve mean delays much lower than those achieved by ZMAC, and QZMAC provides mean delays very close to the minimum achievable in this setting, i.e., that of the centralized complete knowledge scheduler.
Keywordsâˆ’ Sensor Networks, Partially Observable MDPs (POMDPs), Medium Access Control, Throughput Optimality, Optimal Polling, Internet of Things, 6TiSCH.

Contents

1 Introduction

3

1.1 Our Contributions and Organization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5
âˆ—Avi Mohan (corresponding author) is a postdoctoral fellow at the Technion Israel Institute of Technology, Haifa, Israel. E-mail: avinashmohan@campus.technion.ac.il.
â€ Arpan Chattopadhyay is with the Indian Institute of Technology, Delhi, India. E-mail: arpanc@ee.iitd.ac.in â€¡Shivam Vinayak is currently with ABB Bangalore, India. E-mail: shivamv@iisc.ac.in Â§Anurag Kumar is with the Indian Institute of Science, Bangalore-560012, KA, India. E-mail: anurag@iisc.ac.in Â¶This work was done when the ï¬rst author was at the Indian Institute of Science and was presented, in part, at the 13th IEEE International Conference on Mobile Ad Hoc and Sensor Systems (IEEE MASS, 2016). This research was supported by the Ministry of Human Resource Development, via a graduate fellowship for the ï¬rst author, and the Department of Science and Technology, via a J.C. Bose Fellowship awarded to the last author.

1

2 Frame Structure and System Processes

6

3 Information Structure

7

4 Delay-Optimal Polling with Partial Information

8

4.1 A Centralized Scheduling Problem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8

4.2 Optimality of Non-idling and Exhaustive Policies . . . . . . . . . . . . . . . . . . . . . . . . . 9

4.3 The Longest Expected Queue (LEQ) policy . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

4.4 Stability of Cyclic Exhaustive Service . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10

4.5 Delay Optimality of the LEQ policy in Symmetric Systems . . . . . . . . . . . . . . . . . . . 11

4.5.1 Mean Delay Optimality of Cyclic Exhaustive Service . . . . . . . . . . . . . . . . . . . 12

4.5.2 Formulating The Discounted Cost MDP . . . . . . . . . . . . . . . . . . . . . . . . . . 12

4.5.3 Solution to the Discounted Cost MDP . . . . . . . . . . . . . . . . . . . . . . . . . . . 13

4.5.4 The Class of Throughput Optimal Stationary Markov Policies . . . . . . . . . . . . . . 14

4.5.5 The Average-Cost Criterion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15

4.6 Alleviating Short term Unfairness: The K-Longest Expected Queue (KLEQ) Policy . . . . . . 15

5 Mechanisms for Decentralized Scheduling

17

6 Protocol Design

18

6.1 The EZMAC Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

6.1.1 The ZMAC protocol [RWA+08] . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18

6.2 The QZMAC protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20

7 Extending QZMAC

21

7.1 Handling Unequal Arrival Rates . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

7.2 Handling CCA errors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22

8 Experiments on an Implementation of QZMAC

23

8.1 Frame Structure: Time Slots and Mini-Slots . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

8.2 Time Synchronization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

8.3 CCA Errors : Inference and Handling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 24

9 Experimental Results

25

2

9.1 Distributed Implementation of the LEQ policy . . . . . . . . . . . . . . . . . . . . . . . . . . 25 9.2 Performance of EZMAC and QZMAC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 9.3 Tuning QZMAC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 9.4 Channel Utilization . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

10 Conclusion and Future work

29

11 Appendices

33

11.1 Glossary of Notation and Acronyms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33

11.2 Proof of Prop. 1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34

11.3 Proof of Prop. 2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

11.4 LEQ in Symmetric Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

11.5 Proof of Thm. 3 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37

11.6 Formulating the MDP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39

11.7 Proof of Thm. 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41

11.7.1 Monotonicity of ğ½âˆ— (Â·) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42

11.7.2 Proof of Thm. 4 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43

11.8 Proof of Lem. 8 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45

11.9 Proof of Lem. 9 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

11.10Solving the Time-Average Cost MDP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47

11.11Proof of Prop. 6 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50

11.12Channel Errors and Fading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53

11.13Handling Alarm Traï¬ƒc: The QZMACğ‘ protocol . . . . . . . . . . . . . . . . . . . . . . . . . 53

11.13.1 Performance of QZMAC with Alarm Traï¬ƒc . . . . . . . . . . . . . . . . . . . . . . . . 54

11.14Eï¬€ects of Nonidealities in Clear Channel Assessment . . . . . . . . . . . . . . . . . . . . . . . 54

1 Introduction
In the Internet of Things (IoT), wireless access networks will connect embedded sensors to the infrastructure network (see Fig. 1). Since these embedded devices will be resource challenged, the wireless medium access control (MAC) protocols will need to be simple, and decentralized, and not require explicit exchange of state information and control signals. However, some of the emerging applications might expect low packet delivery delays as well. In this paper, we report our work on developing a low mean delay MAC protocol for ğ‘ collocated nodes sharing a time slotted wireless channel, such that there is no centralized control and no explicit exchange of state information. Networks with collocated nodes regularly arise in the industrial
3

Measurement Packets
Packet Buï¬€er

Internet
IoT Gateway

Wireless Sensor Node
Figure 1: A typical application scenario. Each of the ğ‘ sensors generates measurement packets that get queued in its packet buï¬€er. These are then transmitted over a wireless link to a gateway that forwards the packet to the broader internet, i.e., the infrastructure network.
IoT setting such as asset management applications, speciï¬cally, machine health monitoring [ZWX17], and in robotics applications, termed the â€œInternet of Robotic Thingsâ€ (IoRT) [GRC+14, Mat19], owing to their reduced geographical spread (network monitoring a single machine or robot). Emerging standards for IoT applications, such as the DetNet and 6TiSCH [TPE15], have shown considerable interest in systems with a synchronous time-slotted framework. It may be noted that, for this setting, a centralized scheduler with full queue length information can just schedule any non-empty queue in each slot. The challenge we address in this paper is to develop a distributed mechanism, without explicit exchange of queue length information, that achieves mean delay very close to that of the centralized scheduler.
It is well known that, while contention access (ALOHA, CSMA etc.) performs well at low contention, it can result in very large delays and possibly instability under high contention [Le84]. While attempts have been made to stabilize CSMA (see [JW12], [JW11] and [RSS09] for examples), the delay of these algorithms still remains prohibitively high. Polled access (e.g., 1-limited cyclic service [TK85], which we will call TDMA in this paper) on the other hand, shows the opposite behavior. It is, hence, desirable to have protocols that can behave like TDMA under high contention and CSMA under low contention. Fig. 2 illustrates this behavior. The ï¬gure compares the delay performance of polling and contention MACs (orange and blue, respectively) showing the phenomenon discussed above. Also shown are two illustrations of â€œload adaptiveâ€ performance expected of hybrid MACs, the one in red being uniformly better than the one in green. The ï¬gure also shows the lowest possible delay attainable in this setting (black curve). This curve is discussed in more detail in Sec. 9, where we show that the hybrid MACs proposed in this paper come extremely close to this curve and hence, are nearly delay optimal. There have been many attempts at proposing protocols that achieve this, especially in the context of wireless sensor networks. Important examples include [EM+82, DNF+05, RWA+08, AHM+06] and [SSB10]. Among these, ZMAC [RWA+08] has been observed to perform the best in terms of delay and channel utilization (see [WR05]), and will be an important point of comparison in this paper. The design of these protocols, however, has been heuristic and without recourse to known results in optimal scheduling of queues. Further, little attention appears to have been paid to distributed scheduling in the TDMA context, such that each node uses only locally available information. If all queue lengths are known at a central scheduler, then ideal performance can be achieved. In the context of partial information about queue occupancies, the aim, at each scheduling instant, is to minimize the time it takes for the system to ï¬nd a nonempty queue and allow it to transmit. How this can be achieved in the setting of collocated nodes with a common receiver, by using stochastic optimal control (with partial information) in conjunction with extensions of known results on optimal scheduling, is the main contribution of this paper.
4

Figure 2: Delay performance of various MAC protocols. Arrival rates to all queues are equal. In this paper, such a system is termed a symmetric system.
ZMAC achieves contention-dependent behavior by maintaining a TDMA schedule as the basic transmission scheme, and by allowing nodes to contend for slots when the TDMA user is empty. When the network is lightly loaded, most nodes are empty and other nodes can acquire their TDMA slots through contention without waiting for their own TDMA slots, while under heavy load, most nodes use their TDMA slots and the protocol behaves like TDMA, as desired. ZMACâ€™s delay performance, however, is poor compared to centralized scheduling with full queue length knowledge (see Fig. 13b). The question, therefore, remains whether we can achieve low delay, in a decentralized setting, in which the information available to each node is just what it can acquire by â€œlisteningâ€ over the channel.
1.1 Our Contributions and Organization
â€¢ We consider ğ‘ nodes sharing a slotted wireless channel to transmit packets (each of which ï¬ts into one slot) to a common receiver. Each node receives a stochastic arrival process embedded at the slot boundaries.
â€¢ We begin by describing in detail the structure of the (partial) information that nodes in the network will be assumed to possess, in Sec. 3. This structure will inform the development of optimal scheduling policies and distributed scheduling protocols.
â€¢ We then prove the delay optimality of greedy and exhaustive service policies in this novel partial information setting (in Sec. 4.2). While our analysis employs proof techniques in [LNT92] to show sample pathwise dominance, the added complexity of state dependent server switchover delays complicates the analysis in this (and the next) section considerably.
â€¢ Focusing on greedy and exhaustive service policies, with no explicit queue length information being shared between nodes, we derive a mean delay optimal policy by formulating the problem as a Markov decision process with partial information.
â€¢ We initially cast the problem as an ğ›¼-discounted cost MDP and obtain the optimal policy (Sec. 4.5.3). Thereafter, we extend the result to time-average costs in Sec. 4.5.5. Next, we use Foster Lyapunov theory [FMM95] to modify and extend our proposed optimal policy to solve the problem of unfairness that it gives rise to in Sec. 4.6. We also discuss how our results can also handle channel errors and fading.
5

â€¢ We then use the delay optimality results developed in Sec. 4.2 to design two Hybrid MAC protocols (EZMAC and QZMAC) and show that the delays achieved by them are much lower than that achieved by ZMAC (Sec. 6). We then present modiï¬cations to the QZMAC protocol to handle unequal arrival rates, alarm traï¬ƒc and Clear Channel Assessment (CCA) errors. To the best of our knowledge, this is the ï¬rst work that deals with hybrid MAC scheduling for systems with unequal arrival rates (Prop. 2 and Thm. 3).
â€¢ We report the results of implementing QZMAC over a collocated network comprising CC2420 based Crossbow telosB motes running the 6TiSCH [DWVT14] communication stack, in Sec. 8. In Sec. 9, we present simulation results comparing the delay (both mean and delay CDF) performance of QZMAC and EZMAC with that of ZMAC. We also show that delay with QZMAC is very close to the minimum delay that can be obtained in this scenario (Sec. 9.2). We discuss techniques to tune QZMAC to modify its performance over diï¬€erent portions of the network capacity region (see Eqn.(2)) and also compare the Channel Utilization of QZMAC with that of ZMAC. Finally, we conclude the paper and present directions for future research.

2 Frame Structure and System Processes

We consider a wireless network comprising several source nodes (e.g., sensor nodes) transmitting to a common receiver node (e.g., a base station). The nodes are collocated in the sense that all nodes can hear each otherâ€™s transmissions. This could mean, at one extreme, that they can decode each otherâ€™s transmissions, or just sense each otherâ€™s transmissions. We will comment on this further in Sec. 3 on Information Structures. Time is assumed slotted; the slots are indexed ğ‘¡ = 0, 1, 2, Â· Â· Â· , with slot ğ‘¡ being bounded by the epochs ğ‘¡ and ğ‘¡ + 1. In each slot ğ‘¡, a single node can transmit successfully (note that there is a common receiver). If a node transmits in slot ğ‘¡, at the instant ğ‘¡ +1, that node is viewed as the â€œnode under service,â€ or the â€œincumbent,â€ the identity of which is assumed known to all the nodes; as we will see, this property of knowing the incumbent is ensured by the information structure and our distributed algorithms.

We model the system as a network of ğ‘ parallel queues with a single shared server, whose service has to be scheduled between the ğ‘ queues. ğ¼ := {1, 2, Â· Â· Â· , ğ‘ } represents the set of queues. We denote by ğ´ ğ‘— (ğ‘¡), the number of arrivals to Queue ğ‘— at time slot boundary ğ‘¡ (ğ‘¡ = 0, 1, 2, Â· Â· Â· ). ğ´ ğ‘— (ğ‘¡) is assumed IID Bernoulli with rate ğœ† ğ‘— , i.e., ğ‘ƒ{ ğ´ ğ‘— (ğ‘¡) = 1} = ğœ† ğ‘— . The arrival processes are assumed independent of each other and the system backlog. The backlog at Queue ğ‘— at the beginning of time slot ğ‘¡ (i.e., at ğ‘¡+) is denoted by ğ‘„ ğ‘— (ğ‘¡) (see Fig. 3). We assume that each slot can carry exactly one data packet, after allowing time for any protocol overhead. A packet transmission from Node ğ‘— in slot ğ‘¡ leads to a â€œdepartureâ€ from the corresponding queue, which is viewed as occurring at (ğ‘¡ + 1)âˆ’, i.e., just before the end of slot ğ‘¡, and is denoted by ğ· ğ‘— (ğ‘¡). Until Sec. 11.12 we assume packet transmission success probability to be 1 and therein, lift this assumption. It follows, from the embedding of the processes described, that the evolution of the queue-length process at Queue ğ‘— can be described by.
ğ‘„ ğ‘— (ğ‘¡ + 1) = (ğ‘„ ğ‘— (ğ‘¡) âˆ’ ğ· ğ‘— (ğ‘¡))+ + ğ´ ğ‘— (ğ‘¡ + 1), (1)
ğ‘„ ğ‘— (0) = ğ´ ğ‘— (0),
where for all ğ‘¥ âˆˆ R, (ğ‘¥)+ =max(ğ‘¥, 0). Since at most one queue1 can be scheduled for transmission in a slot and at most one packet can be transmitted in one slot, the capacity region [TE92] of this system is given by

ğ‘

âˆ‘ï¸

ğš²=

ğ€

âˆˆ

ğ‘
R+

:

ğœ†ğ‘— < 1 .

(2)

ğ‘— =1

1In the sequel we will use â€œnodeâ€ and â€œqueueâ€ interchangeably.

6

Figure 3: Figure showing how the queue length, arrival and service processes are embedded.

Deï¬ne Q(ğ‘¡) = [ğ‘„1 (ğ‘¡), Â· Â· Â· , ğ‘„ğ‘ (ğ‘¡)] , ğ‘¡ â‰¥ 0. In this article, we say that the system is stable if the system backlog Markov chain, {Q(ğ‘¡), ğ‘¡ â‰¥ 0}, is positive recurrent. A protocol that is capable of stabilizing any vector in Î› is said to be Throughput Optimal [TE92]. Delay is deï¬ned as the number of slots between the instant a packet enters a queue and the instant it leaves the queue. Note that this along with the embedding described so far means that a packet experiences a delay of at least one slot.

Let ğ‘„ ğ‘— =Î” limğ‘¡â†’âˆ 1ğ‘¡ ğ‘¡ğœâˆ’=10 ğ‘„ ğ‘— (ğœ), let ğ‘Š ğ‘— (ğ‘˜) denote the delay experienced by the ğ‘˜ğ‘¡â„ packet in Queue ğ‘— and ğ‘Š ğ‘— =Î” limğ¿â†’âˆ ğ¿1 ğ‘˜ğ¿=âˆ’01 ğ‘Š ğ‘— (ğ‘˜). Under stability, ğ‘„ ğ‘— and ğ‘Š ğ‘— are constant with probability one; we denote these constants also by ğ‘„ ğ‘— and ğ‘Š ğ‘— . Using Littleâ€™s law, ğ‘Š ğ‘— = ğ‘„ğ‘— . The delay experienced by a packet randomly
ğœ†ğ‘—

chosen from the arriving stream, therefore, is given by ğ‘Š =

ğ‘ ğ‘— =1

ğœ†ğ‘—
ğ‘
ğ‘˜=1 ğœ†ğ‘˜

ğ‘Šğ‘— =

1
ğ‘
ğ‘˜=1 ğœ†ğ‘˜

in the paper is to develop decentralized protocols that minimize ğ‘Š .

ğ‘ ğ‘— =1

ğ‘„

ğ‘—

.

Our

objective

3 Information Structure
In the setting described in Sec. 2, if, at the beginning of every slot, the queue lengths are all known to a central scheduler, then it suï¬ƒces to simply schedule any non-empty queue. The sum queue length process would then be stochastically equivalent to a discrete time, work conserving, single server queue, whose arrival process is the superposition of the ğ‘ arrival processes. The mean delay (equivalently, the mean queue length) would then be the smallest possible. We, however, wish to avoid any explicit dissemination of queue length information over the network, and aim to develop a scheduler that the nodes implement in a decentralized fashion. In this section, we describe the information that we permit and, in Sec. 5, describe the mechanisms that will enable us to develop a distributed scheduler.
We will assume that certain common information, useful for scheduling, is available to all the nodes. The scheduler in each node will utilise only this common information, and hence can be implemented in a distributed manner at each of the nodes. As stated in Sec. 2, the nodes can hear each otherâ€™s transmissions.
Queue length sensing: The common information mentioned in the previous paragraph is disseminated by each node including its current queue length in the header whenever it transmits a packet. In such a case, all nodes have a record of each nodeâ€™s queue length until the last time it transmitted. While this assumption is necessary for the proofs in this section, our analysis culminates in the surprising conclusion that reducing mean delay does not require explicit queue length exchange in this setting. We then leverage this result to construct our hybrid MAC protocols.
7

4 Delay-Optimal Polling with Partial Information

Under the information structure described in Sec. 3, at the beginning of each slot, every node will know

the length of every queue at the beginning of every slot in which the queue was allowed to transmit. But

since queue length evolution is Markovian (see Eqn. (2)) the nodes need only keep track of the last observed

queue lengths2, i.e., at the beginning of slot ğ‘¡, each queue knows

ğœ‹
ğ‘„

ğ‘¡ âˆ’ ğ‘‰ ğœ‹ (ğ‘¡) âˆ’ , ğ‘— âˆˆ ğ¼ , where ğ‘‰ ğœ‹ (ğ‘¡)

ğ‘—

ğ‘—

ğ‘—

is the number of slots prior to slot ğ‘¡ in which Queue ğ‘— was allowed to transmit under a generic scheduling

policy ğœ‹ (the term â€œpolicyâ€ is deï¬ned in Sec. 4.1 below). In the literature, ğ‘‰ ğœ‹ (ğ‘¡) is also called â€œAge of
ğ‘—
Informationâ€ [YSB+21]. For example, if ğ‘— is the queue that transmitted in slot (ğ‘¡ âˆ’ 1), then ğ‘‰ ğœ‹ (ğ‘¡) = 0, and
ğ‘—

all

other

nodes

know

ğœ‹
ğ‘„

( (ğ‘¡ ) âˆ’)

(Fig.

3).

In

addition,

at

the

beginning

of

slot

ğ‘¡,

every

node

evidently

knows

ğ‘—

its own queue length. We seek a distributed scheduling policy where each node acts autonomously based on

the queue information structure above, thereby achieving a global performance objective (say, minimising

the time average total queue length in the system).

We will motivate the solution to this problem by considering two centralized decision problems â€“ determining the optimal action when the incumbent is (i) nonempty and (ii) when the incumbent is empty. Notice that despite the centralized nature of the scheduling, our novel partial information structure involving random state-dependent delays renders this analysis nontrivial. The former is developed in Sec. 4.1 and then solved in Sec. 4.2. This leaves us with a centralized average cost Markov decision problem, with partial information, which is formulated and solved in Sec.4.5. Together, the solutions of these two problems provide the distributed scheduler that we need. It turns out that this solution requires a little more information to be shared amongst the queues. In Sec. 5 we use a device from [RWA+08] for providing this additional information to all the nodes, thus paving the way for a practical implementation of the distributed scheduler.

4.1 A Centralized Scheduling Problem

A centralized scheduler is deï¬ned by a scheduling policy say ğœ‹, which (informally speaking), at the beginning of slot ğ‘¡, i.e., at ğ‘¡+, uses the available information and past actions to determine which queue (if any) should
be allowed to transmit in slot ğ‘¡. We indicate the use of a given policy ğœ‹ by placing the superscript ğœ‹ on all processes associated with the system; for example, ğ‘„ ğœ‹ (ğ‘¡), ğ‘¡ âˆˆ {0, 1, Â· Â· Â· } is the queue length process of
ğ‘—
Node ğ‘— under the policy ğœ‹. At the beginning of slot ğ‘¡, ğ‘¡ â‰¥ 1, we denote by ğœ‹ğ‘¡ğ‘âˆ’1, the queue that had been scheduled in the previous slot, or, equivalently the â€œincumbentâ€ at the beginning of slot ğ‘¡.

Under

policy

ğœ‹,

the

action

at

ğ‘¡+

is

denoted

by

Ağœ‹

:=

(ğœ‹ğ‘, ğœ‹ğ‘),

where

ğ‘
ğœ‹

represents

the

action

to

be

taken

ğ‘¡

ğ‘¡ğ‘¡

ğ‘¡

during slot ğ‘¡ and ğœ‹ğ‘¡ğ‘, the queue upon which the action is to be performed. ğœ‹ğ‘¡ğ‘ âˆˆ {0, 1, ğ‘ 0, ğ‘ 1} which mean

respectively,

idle

at

ğ‘
ğœ‹
ğ‘¡

=

ğœ‹ğ‘¡ğ‘âˆ’1,

serve

ğ‘
ğœ‹
ğ‘¡

=

ğ‘
ğœ‹ğ‘¡ âˆ’1

if

nonempty,

switch

(away

from

queue

ğœ‹ğ‘¡ğ‘âˆ’1)

to

ğ‘
ğœ‹
ğ‘¡

and

idle

there,

and

switch

to

ğ‘
ğœ‹

and

serve

it

if

nonempty,

respectively.

With

the

above

in

mind,

and

anticipating

a

ğ‘¡

result similar to [LNT92, Prop. 3.2], we consider a centralized scheduler that has the following information.

For every ğ‘¡ â‰¥ 1 and policy ğœ‹, the â€œhistoryâ€ of the policy contains (i) all the actions taken until ğ‘¡ âˆ’ 1, (ii) the

backlog of each queue at the last instant it was allowed to transmit, (iii) the instants at which this backlog

was revealed, and (iv) the backlog of the incumbent3 at ğ‘¡, i.e.,

ğœ‹
ğ»

:=

Ağœ‹

ğ‘¡ âˆ’1

;

ğœ‹
ğ‘„

ğ‘

ğ‘

ğ‘¡ âˆ’ ğ‘‰ ğœ‹ (ğ‘¡) âˆ’ ; ğ‘‰ ğœ‹ (ğ‘¡) ; ğ‘„ğœ‹

(ğ‘¡) .

(3)

ğ‘¡

ğ‘š ğ‘š=0

ğ‘—

ğ‘—

ğ‘— =1

ğ‘—

ğ‘
ğ‘—=1 ğœ‹ğ‘¡âˆ’1

2If Node ğ‘– transmits in slot ğ‘¡, the other nodes get to know ğ‘„ğ‘– (ğ‘¡), and since a packet was transmitted, they can infer
ğ‘„ğ‘– ( (ğ‘¡ + 1) âˆ’) = ğ‘„ğ‘– (ğ‘¡) âˆ’ 1. However, the process embedding we have assumed prevents the queues from knowing ğ‘„ğ‘– (ğ‘¡ + 1) itself, since ğ‘„ğ‘– (ğ‘¡ + 1) = (ğ‘„ğ‘– (ğ‘¡) âˆ’ 1)+ + ğ´ğ‘– (ğ‘¡ + 1) and ğ´ğ‘– (ğ‘¡ + 1) is not known.
3Once again, since the evolution of the system is Markovian, we do not require information about arrivals.

8

Note that ğ»ğ‘¡ğœ‹ is common knowledge.

Let

ğœ‹
Hğ‘¡

denote

the

set

of

all

histories

under

ğœ‹

up

to

time

ğ‘¡.

A

deterministic

admissible

policy

is

deï¬ned

as

a

sequence

of

measurable

functions

from

ğœ‹
Hğ‘¡

into

the

action

space A = {0, 1, ğ‘ 0, ğ‘ 1} Ã— ğ¼. For policy ğœ‹, deï¬ne

ğ‘
âˆ‘ï¸ ğ‘„ ğœ‹ (ğ‘¡) = ğ‘„ğ‘–ğœ‹ (ğ‘¡), (4)
ğ‘–=1
as the total backlog in the system at the beginning of time slot ğ‘¡, âˆ€ğ‘¡ â‰¥ 0. Let the space of all admissible policies be denoted by Î . A policy ğœ‹ âˆˆ Î  is said to be

â€¢ greedy or non-idling if the server never idles at a nonempty queue. The set of all such policies is denoted by Î ğ‘” âŠ‚ Î , i.e., Î ğ‘” = ğœ‹ âˆˆ Î  ğ‘„ ğœ‹ğ‘ (ğ‘¡) > 0 â‡’ Ağ‘¡ğœ‹ âˆˆ {1, ğ‘ 0, ğ‘ 1} Ã— ğ¼, âˆ€ğ‘¡ â‰¥ 0 .
ğ‘¡ âˆ’1
â€¢ exhaustive if the server never switches away from a nonempty queue. This set is denoted by Î ğ‘’ âŠ‚ Î , i.e., Î ğ‘’ = ğœ‹ âˆˆ Î  ğ‘„ ğœ‹ğ‘¡ğ‘âˆ’1 (ğ‘¡) > 0 â‡’ Ağ‘¡ğœ‹ âˆˆ {0, 1} Ã— ğœ‹ğ‘¡ğ‘âˆ’1 , âˆ€ğ‘¡ â‰¥ 0

We will now present several results with regards to scheduling in this system that will aid our design process.

4.2 Optimality of Non-idling and Exhaustive Policies

Proposition 1. For the system deï¬ned in Sec. 4 and for any policy ğœ‹ âˆˆ Î , âˆƒ ğœ‰ âˆˆ Î ğ‘” âˆ© Î ğ‘’, such that

ğ‘ ğ‘¡

ğ‘„ ğœ‰ (ğ‘¡) â‰¤ ğ‘„ ğœ‹ (ğ‘¡), âˆ€ ğ‘¡ â‰¥ 0,

(5)

where â€œğ‘ ğ‘¡â€ denotes stochastic ordering.

Proof. The structure of the model is similar to the one in [LNT92], and the result we seek is the same as [LNT92, Prop. 4.2]. There, the model is a centrally scheduled system of queues, with i.i.d. service times, non zero i.i.d. queue switching times4, and knowledge of ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ ğœ‹ ), 1 â‰¤ ğ‘– â‰¤ ğ‘ . Since switching times are
ğ‘–,ğ‘¡
nonzero, by exhaustively serving a queue the per packet switching time is reduced, rather than switching away from a non-empty queue and then switching back to it in order to complete the service of the remaining packets. However, a crucial assumption in [LNT92] is that the scheduler instantaneously obtains the queue length of every queue to which it switches. This is important since this limits their study to schedulers that never waste time attempting to serve empty queues, since, upon ï¬nding a queue empty, the scheduler is assumed to immediately switch away to another queue.
In our system, all queues can observe the empty or non empty status of a transmitter whenever it is allowed to transmit. However, while there are no explicit switching times, due to decentralized scheduling, at switching instants, time could be wasted by switching to empty queues, although other nonempty queues exist. In Sec.11.2 in the Appendix, we extend the stochastic coupling argument in [LNT92] to establish the same result as in [LNT92, Prop. 4.2].
4In polling literature, switching/switchover times refer to the time wasted while the server switches from one queue to another.

9

Discussion: Prop. 1 leads to the following partial solution for scheduling. Consider the situation in which an incumbent node completes a transmission, with all other nodes knowing its identity. This node must continue transmission until its queue is empty; this is a direct application of Prop. 1. As mentioned before, in Sec. 5, we discuss mechanisms by which the other nodes detect the fact that the node under service is now empty. At this point the problem is to select the next node for transmission. Given the greedy and exhaustive mechanism, it is then clear that at each scheduling instant the common information available to the centralized scheduler (and, in our system, to all nodes) is ğ‘‰ ğœ‹ (ğ‘¡), the number of slots since each queue was
ğ‘—

last

served

(since

exhaustive

service

renders

ğœ‹
ğ‘„

ğ‘¡ âˆ’ ğ‘‰ ğœ‹ (ğ‘¡) âˆ’ = 0, âˆ€ ğ‘—). Given this common information,

ğ‘—

ğ‘—

which queue should be scheduled next so that mean delay is small? We answer this question in sections 4.3

and 4.5 .

4.3 The Longest Expected Queue (LEQ) policy

Let

the

arrival

rate

vector

be

denoted

by

ğ€

(âˆˆ

R

ğ‘ +

).

For

the

time

being,

this

information

will

be

assumed

to

be known to all queues, but we will lift this assumption in Sec. 9.1. For notational convenience, in the sequel,

we denote the number of slots since Queue ğ‘– was last served, formerly denoted ğ‘‰ ğœ‹ (ğ‘¡), by ğ‘‰ğ‘– (ğ‘¡) (omitting the
ğ‘–

policy superscript). Since we consider exhaustive service, ğœ†ğ‘–ğ‘‰ğ‘– (ğ‘¡) is the expected backlog of queue ğ‘– at ğ‘¡, and

ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥1â‰¤ğ‘–â‰¤ğ‘ ğœ†ğ‘–ğ‘‰ğ‘– (ğ‘¡) is the longest expected backlog. We call the policy that, at every scheduling instant,

schedules this queue the Longest Expected Queue (LEQ) policy.

Proposition 2. The LEQ policy stabilizes all arrival rate vectors in the set

ğ‘

âˆ‘ï¸

Î›ğ¿ğ¸ğ‘„ :=

ğ€

âˆˆ

ğ‘
R+

ğœ†ğ‘– < 1 and min ğœ†ğ‘– > 0 .

(6)

1â‰¤ğ‘– â‰¤ğ‘

ğ‘–=1

Proof. The proof essentially involves showing that the expected time to ï¬nd the next nonempty queue (after serving some queue exhaustively) is bounded. Refer to Sec. 11.3 in the Appendix for details of the proof.

Comparing the deï¬nition of the region Î›ğ¿ğ¸ğ‘„ with that of the region Î› in Eqn.(2) shows, quite clearly, that the LEQ policy is throughput optimal. We say that the system is â€œsymmetricâ€ or â€œhomogeneous,â€ when

ğœ†ğ‘– = ğœ† âˆ€ğ‘– âˆˆ ğ¼.

(7)

In Sec. 11.4, we show that under symmetry (Eqn. (7)), ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥1â‰¤ğ‘–â‰¤ğ‘ ğœ†ğ‘–ğ‘‰ğ‘– (ğ‘¡) = ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥1â‰¤ğ‘–â‰¤ğ‘ ğ‘‰ğ‘– (ğ‘¡) and the policy reduces to a cyclic exhaustive service policy.

4.4 Stability of Cyclic Exhaustive Service
Before we embark on the analysis of this policyâ€™s delay performance, we make an important observation about its stability. The cyclic exhaustive service policy is throughput optimal. The proof of the stability of the cyclic exhaustive service policy proceeds along the lines of the analysis in [AKL92]. Note, however, that the stability of this policy is proved for a system with general (possibly unequal) arrivals rates ğœ†1, Â· Â· Â· , ğœ†ğ‘ , and includes, as a special case, the stability of the symmetric system. Formally,
Theorem 3. Consider the system capacity region deï¬ned in Eqn. (2). If ğ€ âˆˆ Î›, the system is stable under cyclic exhaustive service.
10

Comparison of Scheduling algorithms (20 queues) 70

Expected Delay (slots)

60

LEQ

50

Cyclic Exhaustive Service

Centralized Fullâˆ’knowledge Scheduler

40

30

20

10

0

0

0.2

0.4

0.6

0.8

1

Î£k Î»k (pkts/slot)

Figure 4: Comparison of the performance of the LEQ and Cyclic Exhaustive Service policies. Also shown is the lowest possible

delay achievable in this system (black curve). This is discussed in detail in Sec. VI. We assume a ï¬xed ratio of packet rates

that determines the arrival to each queue. Speciï¬cally, ğœ†ğ‘˜ = ğ‘Ÿğ‘˜ ğœ† is the arrival rate to Queue ğ‘˜ with

ğ‘
ğ‘˜=1 ğ‘Ÿğ‘˜

= 1.

In the plot,

ğœ† âˆˆ [0, 1).

Proof. The proof involves showing that the drift of a Lyapunov function computed at the end of ğ‘ busy periods, i.e., between two successive returns to any queue ğ‘–, is negative. Refer to Sec. 11.5 in the Appendix for details.
Remark. Although we motivated cyclic exhaustive service as the LEQ policy specialized to symmetric systems, Thm. 3 shows that the former can actually stabilize unequal arrival rates as well. So we now have two throughput optimal scheduling policies (LEQ and cyclic exhaustive service). But since the LEQ policy requires estimates of the arrival rate vector and cyclic exhaustive service does not, can we do away with LEQ altogether? As Fig. 4 shows, with unequal arrival rates, LEQ can deliver substantially better delay performance and hence, is preferable to cyclic exhaustive service. In Sec. 9, we show how LEQ can be implemented in a distributed manner using arrival rate estimation, but where such estimation cannot be performed or is undesirable, cyclic exhaustive service can still be used to stabilize the system albeit at the cost of increased delay.

4.5 Delay Optimality of the LEQ policy in Symmetric Systems

We will now show that the LEQ policy specialized to symmetric systems, or the cyclic exhaustive service policy is mean delay optimal. The stability region for a symmetric system is obviously the interval ğœ† = [0, 1 ).
ğ‘
Recall that all scheduling decisions are made at the beginnings of slots and the only information available
then is whether the incumbent queue is empty and the number of slots since each queue in the system was last allowed to transmit 5. So, if the queue polled next turns out to be empty, the system wastes the entire
slot without transmitting any packets even if the other queues are nonempty.

ğ‘‰ğ‘– (ğ‘¡) is the last time Queue ğ‘–'s backlog was known to the system before time slot ğ‘¡. We call a policy ğœ‹ âˆˆ Î 

an SLQ (stochastically largest queue) policy if, at every instant ğ‘¡, in which a switchover takes place, the

new queue chosen is not stochastically smaller than any other queue in the system. Formally, this means

that

whenever

ğ‘
ğœ‹
ğ‘¡

â‰ 

ğœ‹ğ‘¡ğ‘âˆ’1,

ğ‘‰ğœ‹ğ‘ (ğ‘¡)

â‰¥

ğ‘‰ğ‘˜ (ğ‘¡)

for

every

ğ‘˜

âˆˆ

ğ¼.

The name SLQ arises from the fact that if

ğ‘¡

ğ‘‰ğ‘™ > ğ‘‰ğ‘˜ , and the two queues were served exhaustively, their current queue lengths, with Bernoulli arrivals,

5Note that, by Prop. 1, the additional knowledge that the incumbent queue has of its own queue length is not useful, since it is optimal for the incumbent to continue to transmit until its own queue is empty.

11

are Binomial(ğ‘‰ğ‘™, ğœ†) and Binomial(ğ‘‰ğ‘˜ , ğœ†) random variables respectively. Under these conditions, we know that Binomial(ğ‘‰ğ‘™, ğœ†) is stochastically larger than Binomial(ğ‘‰ğ‘˜ , ğœ†). Hence, the name.
Note that when ğ‘‰ğ‘™ â‰  ğ‘‰ğ‘˜ and ğœ†ğ‘™ â‰  ğœ†ğ‘˜ , it might not even be possible to stochastically order random variables distributed according to Binomial(ğ‘‰ğ‘™, ğœ†ğ‘™) and Binomial(ğ‘‰ğ‘˜ , ğœ†ğ‘˜ ). An example is when ğ‘‰ğ‘™ > ğ‘‰ğ‘˜ , but ğœ†ğ‘™ < ğœ†ğ‘˜ . Hence, with unequal arrival rates, the LEQ policy doesnâ€™t necessarily choose the stochastically longest queue, but only the queue with the largest mean backlog. This is the diï¬€erence between the LEQ and SLQ policies. In the sequel, we denote the set of all SLQ policies by Î ğ‘ .
Remark. Here, it should ï¬rst be noted that Prop. 5.1 of [LNT92] cannot be directly used with the present information structure, since the optimal policies derived therein have the property that the server never dwells at an empty queue. However, as mentioned at the end of Sec. 3, the queues only know if a queue was non-empty the last time it was polled. This always leaves open the possibility of scheduling an empty queue and wasting the entire slot. It is this slot-wastage conditioned on the chosen queue being empty that complicates matters, and also prevents us from simply reinterpreting such slots as switchover times.
We now explicitly derive the delay optimal policy for symmetric systems by presenting an expected delay version of the same result that uses the theory of Markov Decision Processes and is also of independent theoretical interest.

4.5.1 Mean Delay Optimality of Cyclic Exhaustive Service

Motivated by Prop. 1, we restrict ourselves to policies in which the channel is acquired by another queue

only if the queue under service is empty at the beginning of a slot. Suppose the queue scheduled in slot ğ‘¡

is denoted by {ğ‘¢ğ‘¡ , ğ‘¡ â‰¥ 0}. We seek a policy, say ğœ‹, to choose ğ‘¢0, ğ‘¢1, Â· Â· Â· so as to minimize the following cost

function

1

ğ‘‡ âˆ’1 ğ‘
âˆ‘ï¸ âˆ‘ï¸

lim sup Eğ‘ (0)

ğ‘„ğ‘–(ğ‘¡) ,

(8)

ğ‘‡ â†’âˆ ğ‘‡

ğ‘¡=0 ğ‘–=1

where ğ‘ (0) = [ğ‘„1 (0), Â· Â· Â· , ğ‘„ğ‘ (0)] is the initial state of the system. This is the mean long-term backlog in

the system and, as described at the end of Sec. 2 can be used as a proxy for mean delay. In order to solve

this problem, we ï¬rst cast it as an ğ›¼-discounted cost minimization problem which involves minimizing the

cost function

âˆ

ğ‘

âˆ‘ï¸ âˆ‘ï¸

ğ‘¡
Eğ‘  (0) ğ›¼

ğ‘„ğ‘–(ğ‘¡) ,

(9)

ğ‘¡ =0

ğ‘–=1

where ğ›¼ âˆˆ (0, 1) is the discount factor. We will later arrive at the solution to the long-term time averaged cost, (8), using a limiting procedure with a sequence of optimal policies ğœ‹ğ‘˜ corresponding to a sequence of discount factors ğ›¼ğ‘˜ â†‘ 1. In what follows, we invoke the results of Propn. 1, and focus only on Î ğ‘” âˆ© Î ğ‘’.

4.5.2 Formulating The Discounted Cost MDP
In order to derive the optimal scheduling policy, we will slightly generalize the information structure as follows. At the beginning of slot ğ‘¡ all the queues know (i) the incumbent (ii) the number of slots since every queue was last served {ğ‘‰ğ‘˜ (ğ‘¡), ğ‘˜ âˆˆ ğ¼} (iii) the queue-length of the incumbent, and (iv) residual known queue lengths in the queues (if any). It will turn out that the optimal policy (a) is a function only of the ğ‘‰ğ‘˜ s and the empty-nonempty status of the incumbent, and (b) serves queues exhaustively, so the residual known queue lengths in the queues are all zero. Thus, the information structure we have in our problem is suï¬ƒcient to implement the optimal policy we derive and this generalization is only required for the proof of delay optimality to go through.
12

The MDP, under the information structure wherein the queues know the backlog of the incumbent and V(ğ‘¡) = [ğ‘‰1 (ğ‘¡), Â· Â· Â· , ğ‘‰ğ‘ (ğ‘¡)]ğ‘‡ , has ğ‘ (ğ‘¡) = ğ‘„ğ‘¢ğ‘¡âˆ’1 (ğ‘¡); V(ğ‘¡); r(ğ‘¡); ğ‘¢ğ‘¡âˆ’1 ğ‘‡ as its state. The new coordinate r(ğ‘¡) is explained as follows. At the beginning of slot ğ‘¡ (just after arrivals occur), the server knows that queue ( ğ‘— â‰  ğ‘¢ğ‘¡âˆ’1) has length ğ‘Ÿ ğ‘— (ğ‘¡) + ğ‘ˆ ğ‘— and ğ‘ˆ ğ‘— is a Binomial(ğ‘‰ğ‘— (ğ‘¡), ğœ†) random variable. To accommodate this new information, we expand our focus to the class of policies that always serve any queue ğ‘— such that ğ‘Ÿ ğ‘— (ğ‘¡) > 0 in time slot ğ‘¡. This means that if some queue ğ‘— has ğ‘Ÿ ğ‘— (ğ‘¡) > 0 at the beginning of time slot ğ‘¡, it is served in that slot and not the incumbent (ğ‘¢ğ‘¡âˆ’1), even if ğ‘„ğ‘¢ğ‘¡âˆ’1 (ğ‘¡) > 0.
But these policies are still greedy and exhaustive, in the (restricted) sense that whenever r(ğ‘¡) = 0 and ğ‘„ğ‘¢ğ‘¡âˆ’1 (ğ‘¡) > 0, ğ‘¢ğ‘¡ = ğ‘¢ğ‘¡âˆ’1, i.e., if no other queue is known to have packets and the incumbent is non empty, it is served. This is a purely technical construction required for the proof of Thm. 4 and, as we will show later, the optimal policy (i.e., cyclic exhaustive service) will not require the knowledge of r(ğ‘¡) at all. The action in every slot ğ‘¡ with an empty incumbent, involves choosing a queue ğ‘¢ğ‘¡ âˆˆ ğ¼ and the single-step cost is the expected sum of the current queue lengths conditioned on the current state, given by

ğ‘

âˆ‘ï¸

âˆ‘ï¸

âˆ‘ï¸

ğ‘(ğ‘ (ğ‘¡), ğ‘¢ğ‘¡ ) = E ğ‘„ğ‘– (ğ‘¡)|ğ‘ ğ‘¡ = ğ‘„ğ‘¢ğ‘¡âˆ’1 (ğ‘¡) + ğœ† ğ‘‰ğ‘— (ğ‘¡) + ğ‘Ÿğ‘– (ğ‘¡). (10)

ğ‘–=1

ğ‘— â‰ ğ‘¢ğ‘¡ âˆ’1

ğ‘–âˆˆğ¼

Deï¬ne the state space as S := N Ã— Nğ‘ Ã— Nğ‘ Ã— ğ¼ and optimal discounted cost ğ½âˆ— : S â†¦âˆ’â†’ R+ starting in state

ğ‘ (0) âˆˆ S as

âˆ

ğ‘

ğ½âˆ— (ğ‘ (0)) = ğ‘šğ‘–ğ‘› ğœ‰ Eğ‘ ğœ‰(0) âˆ‘ï¸ ğ›¼ğ‘¡ E âˆ‘ï¸ ğ‘„ğ‘– (ğ‘¡)|ğ‘ (ğ‘¡) , (11)

ğ‘¡ =0

ğ‘–=1

and let ğ‘ represent the backlog of queue ğ‘–, the in-service queue. Note once again, that we have restricted our
focus to policies within Î ğ‘” âˆ© Î ğ‘’. The Bellman Optimality equations [Ber95] associated with the COMDP formulation as described above are as given in (12) (we denote ğ½âˆ— (ğ‘; V; r; ğ‘–) by ğ½âˆ— (ğ‘; V; r)).
ğ‘–

ğ½âˆ—(ğ‘

>

0;

V;

r

=

0)

=

ğ‘

+

ğœ†

âˆ‘ï¸ ğ‘‰

+ ğ›¼Eğ½âˆ—

ğ‘ âˆ’ 1 + ğ´; ğ‘‰

= 0, Vâˆ’

+ 1; r = 0 ,

ğ‘–

ğ‘˜

ğ‘–

ğ‘–

ğ‘–

ğ‘˜ â‰ ğ‘–

ğ½ğ‘–âˆ— (ğ‘ = 0; V; r = 0) = ğœ† âˆ‘ï¸ ğ‘‰ğ‘˜ + ğ›¼ min Eğ½âˆ—ğ‘— ğµ(ğ‘‰ğ‘— ); ğ‘‰ğ‘— = 0, Vâˆ’ ğ‘— + 1; r = 0 , (12)
ğ‘— â‰ ğ‘– ğ‘˜ â‰ ğ‘–
In (12), ğ´ is a generic Bernoulli(ğœ†) random variable, Vâˆ’ğ‘– = [ğ‘‰1, Â· Â· Â· , ğ‘‰ğ‘–âˆ’1, ğ‘‰ğ‘–+1, Â· Â· Â· , ğ‘‰ğ‘ ] and 1 âˆˆ R(ğ‘ âˆ’1) is the vector with 1â€™s at all coordinates. Finally, if random variable ğ¶ is distributed Binomial(ğ‘‰ğ‘— , ğœ†), ğµ(ğ‘‰ğ‘— ) is a random variable whose distribution is the same as that of (ğ¶ âˆ’ 1)+ + ğ´. The detailed formulation of the MDP and the Bellman Optimality equations for the case where ğ‘Ÿ ğ‘— â‰¥ 1 for some ğ‘— âˆˆ ğ¼ âˆ’ {ğ‘–} can be found in Sec. 11.6 in the Appendix.
4.5.3 Solution to the Discounted Cost MDP
Clearly, no decision needs to be taken when either ğ‘ > 0 or (from Prop. 1,) when r â‰  0. Since the policies we seek are non-idling and exhaustive, they will simply continue to serve the incumbent when ğ‘ > 0 and therefore, states with r â‰  0 never actually arise. We will now show that if ğ‘ = 0 and r = 0, the system must choose ğ‘› := arg max ğ‘— ğ‘‰ğ‘— . In what follows, let ğ‘‰ğ‘š < ğ‘‰ğ‘› for some ğ‘š âˆˆ ğ¼, and ğ‘› â‰  ğ‘š. We now prove that choosing ğ‘› results in the least cost.

13

Theorem 4. When ğ‘‰ğ‘š < ğ‘‰ğ‘›,
Eğ½ğ‘›âˆ— ğµ(ğ‘‰ğ‘›); ğ‘‰ğ‘› = 0, Vâˆ’ğ‘› + 1; râˆ’ğ‘› = 0 â‰¤ Eğ½ğ‘šâˆ— ğµ(ğ‘‰ğ‘š); ğ‘‰ğ‘š = 0, Vâˆ’ğ‘š + 1; râˆ’ğ‘š = 0 .
Hence, cyclic exhaustive service solves the discounted cost MDP.
Proof. The proof of the theorem can be found in Sec. 11.7 in the Appendix. Intuitively, with equal mean arrival rates, the queue that has not received service the longest is also the most likely to be non-empty. Hence, attempting to serve this queue will result in the slot being wasted with the least probability.
The policy above, denoted ğœ‹âˆ— in what follows, chooses arg max ğ‘— ğ‘‰ğ‘— (ğ‘¡) in every slot ğ‘¡ with an empty incumbent; in addition, by the exhaustive service r(ğ‘¡) = 0 for all ğ‘¡. In other words, ğœ‹âˆ— is a stationary Markov policy that, at the beginning of each slot, chooses the incumbent, if nonempty, and the queue that has not been served the longest until that epoch, if the incumbent is found empty. Recall from Sec. 4.3 that ğœ‹âˆ— is the cyclic exhaustive policy. In the sequel, we will use these two terms (â€œğœ‹âˆ—â€ and â€œcyclic exhaustive serviceâ€) interchangeably.
4.5.4 The Class of Throughput Optimal Stationary Markov Policies
We would next like to see if the class of stabilizing stationary Markov policies on these state and action spaces is a singleton, and if not, whether all policies in this class have the same cost. Obviously, both these situations would result in ğœ‹âˆ— being a trivial solution to the MDP problem and hence, need to be discussed in detail. We now prove that that is, in fact, not the case.
Proposition 5. For the information structure in Sec. 4, the class of throughput optimal, Markov scheduling policies is not a singleton.
Proof. First, recall that ğœ‹âˆ— itself is stabilizing as proved in Sec. 4.4. Next, consider a policy ğœ‹ âˆˆ Î ğ‘” âˆ© Î ğ‘’, starting with a given vector V(0) = V (ğœ‹âˆ— starts with the same vector). When the in-service queue empties, ğœ‹ chooses ğ‘š := ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥1â‰¤ ğ‘— â‰¤ğ‘ ğ‘‰ğ‘— except when V âˆˆ ğ‘† âŠ‚ Nğ‘ where ğ‘† is some ï¬nite set. On ğ‘† , ğœ‹ makes a suboptimal choice and deviates from ğœ‹âˆ—, e.g., choosing ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥ ğ‘—â‰ ğ‘šğ‘‰ğ‘— . Clearly, this policy is stationary and Markov. We need to establish that it is also throughput optimal. Recall that Q(ğ‘¡) âˆˆ Nğ‘ denotes the vector of backlogs at time ğ‘¡. Now, since ğœ‹âˆ— itself is stabilizing, by the Foster-Lyapunov criterion [FMM95, Thm 2.2.3], there exists6 a non-negative function, ğ‘¦ : Nğ‘ â†’ R+, ğœ– > 0 and a ï¬nite set ğ´ âŠ‚ Nğ‘ , such that,
â‰¤ âˆ’ğœ–, âˆ€ q âˆ‰ ğ´, and E [ğ‘¦(Q(ğ‘¡ + 1)) âˆ’ ğ‘¦(Q(ğ‘¡))|Q(ğ‘¡) = q]
< âˆ, âˆ€ q âˆˆ ğ´.
By expanding ğ´ to ğ´ = ğ´ âˆª ğ‘† , and using the same Lyapunov function ğ‘¦, the Foster-Lyapunov criterion shows that ğœ‹ is also stabilizing. Thus, considering the number of such subsets ğ‘† that can be chosen, we see that Î ğ‘” âˆ© Î ğ‘’ contains inï¬nitely many stabilizing stationary Markov policies.
6The Foster-Lyapunov criterion is both necessary and suï¬ƒcient.
14

Collocated System with 30 queues
70 Ï€*

60

Ï€
1

Ï€
2

50

Ï€

3

40

Expected Delay

30

20

10 0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 Î»

Figure 5: ğœ‹1, ğœ‹2 and ğœ‹3 are suboptimal stabilizing stationary Markov policies, corresponding to ğ‘˜ = 40, 50 and 80 respectively. This ï¬gure clearly shows that the class of stabilizing stationary Markov policies is not a singleton.

Moreover, these policies do not have the same cost! Suppose we deï¬ne the set ğ‘† above to be the set
{0, 1, Â· Â· Â· , ğ‘˜ }ğ‘ . This means ğœ‹ will make sub-optimal decisions whenever 0 â‰¤ ğ‘‰ğ‘– (ğ‘¡) â‰¤ ğ‘˜, âˆ€ğ‘– âˆˆ ğ¼. Fig.5 shows the diï¬€erence in cost between ğœ‹âˆ— and three other policies ğœ‹1, ğœ‹2 and ğœ‹3 corresponding to ğ‘˜ = 40, 50 and 80. Note that all three policies are in Î ğ‘” âˆ© Î ğ‘’ and are stabilizing, stationary and Markovian.

4.5.5 The Average-Cost Criterion
We use the technique described in [Sen89] to show that ğœ‹âˆ— is optimal for the long term time-averaged cost criterion as well. We consider a sequence of discount factors {ğ›¼ğ‘›} â†‘ 1 and the corresponding optimal policies and show that under certain conditions, the limit point of this sequence solves the Average-Cost problem, i.e., (8). For details, refer Sec. 11.10 in the Appendix.
Recall that we began this section with the aim of solving two centralized scheduling problems. Sec. 1 solved the ï¬rst, and we have now solved the second centralized, i.e., the optimal action the system needs to take when the incumbent is empty.

4.6 Alleviating Short term Unfairness: The K-Longest Expected Queue (KLEQ) Policy

While exhaustive service is delay optimal, it obviously exhibits short-term unfairness, especially at high arrival rates with the incumbent being served for long periods while other queues remain starved. While this might not be a cause of too much concern at low loads, near saturation, busy periods tend to be very long and starving queues might not be a good idea, especially if the application requires timely delivery of packets.

One of the ways of quantifying unfairness is by deï¬ning a â€œFairness Indexâ€, J (ğ‘¡), as in [JCH84]. In our model, suppose we deï¬ne ğ‘¥ğ‘– (ğ‘¡), 1 â‰¤ ğ‘– â‰¤ ğ‘ to be the fraction of time-slots in {0, 1, Â· Â· Â· , ğ‘¡} during which queue ğ‘– was scheduled. Then, the fairness index at time ğ‘¡ is deï¬ned as

2

ğ‘ ğ‘–=1

ğ‘¥ğ‘–

(ğ‘¡

)

J (ğ‘¡) =

.

(13)

ğ‘

ğ‘ ğ‘–=1

ğ‘¥ğ‘–

(ğ‘¡

)2

15

It can be shown, using the Cauchy-Schwarz inequality, that 1 â‰¤ J (ğ‘¡) â‰¤ 1, âˆ€ğ‘¡ and the closer J (ğ‘¡) is to 1,
ğ‘
the fairer the allocation/algorithm [JCH84].
Fig. 6a compares the fairness indices of TDMA and Cyclic Exhaustive Service, near saturation (for a symmetric system with ğ‘ = 30 queues, ğœ† < 1 â‰ˆ 0.033). The computation is over a period of 2 Ã— 104 slots (we
ğ‘
wait for the queue length processes to attain stationarity and only then record J (ğ‘¡) for 2 Ã— 104 slots) by which time, the indices attain their maximum value of 1. We see that although cyclic exhaustive service is delay optimal, it does exhibit short-term unfairness. The curious form of the curves corresponding to TDMA in ï¬gures 6a and 6b respectively is due to the cyclic nature of the underlying TDMA schedule. Consider the TDMA fairnes curve. Since every queue gets scheduled exactly once every ğ‘(= 30) slots, J (ğ‘¡) shows the corresponding periodicity (notice that the swings have a period of 30). So, over slots 31 through 60 for example, J (ğ‘¡) ï¬rst decreases, since the ï¬rst few queues get scheduled for a second time (while the others have been scheduled only once over slots 1 through 30) and then increases as this disparity reduces.

Fairness Index Fairness Index

Symmetric System with 30 queues (Î» = 0.03) 1

0.8

0.6

0.4

0.2 TDMA
Cyclic Exhaustive Service

0

100

101

102

103

104

105

t (slots)

(a) Comparing short term unfairness with TDMA and the cyclic exhaustive service policy, i.e., ğœ‹âˆ—. TDMA clearly outperforms ğœ‹âˆ— in this regard.

Symmetric System with 30 queues (Î» = 0.03) 1

0.8

0.6

0.4

KLEQ (K=1)

KLEQ (K=2)

0.2

Cyclic Exhaustive Service

TDMA

0

100

101

102

103

104

105

t (slots)

(b) Improvement in fairness with the KLEQ policy.

Figure 6: Alleviating short term unfairness through the KLEQ policy.

Towards alleviating this problem, consider the space Î ğ¾ âŠ‚ Î  of policies that do not permit a queue to transmit for more than ğ¾ â‰¥ 1 slots consecutively. Such policies are called ğ¾ limited service policies. It is important to note that not all policies in Î ğ¾ are throughput optimal. One prominent example is cyclic service, where, after serving queue ğ‘– (for at most ğ¾ slots), the server visits queue ğ‘– mod ğ‘ + 1; refer [Tak88] for more details about the capacity regions of this policy and some of its variants. This means that the problem of deciding to which queue the system (server) should switch once a queue is empty or served for ğ¾ consecutive slots, is non trivial. Here, we propose a policy that is both fair and throughput optimal. The proposed policy ğœ‹ğ¾ âˆˆ Î ğ¾ serves a queue for a maximum of ğ¾ â‰¥ 1 slots, and thereafter chooses to serve ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥1â‰¤ğ‘– â‰¤ğ‘ ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ğ‘– (ğ‘¡)) + ğœ†ğ‘–ğ‘‰ğ‘– (ğ‘¡).

Proposition

6.

For

all

ğ¾

â‰¥

1

and

ğ€

âˆˆ

ğ‘
R+

such

that

ğ‘
ğ‘–=1 ğœ†ğ‘–

<

1,

ğœ‹ğ¾

is

stabilizing.

Proof. The proof involves bounding the ğ¾ slot conditional expected drift of a novel Lyapunov function. Refer Sec. 11.11 in the Appendix for details.
As can be seen from Fig. 6b, the KLEQ algorithm indeed improves fairness. In fact, with ğ‘˜ = 1 and ğ‘˜ = 2, KLEQ is able to achieve a fairness of 50%, about 100 and 90 slots before ğœ‹âˆ— respectively. However, even more dramatic improvement in fairness is not possible, since stability pulls the protocol towards repeatedly
16

Figure 7: Illustrating the slot and minislot structures. Since ğ‘‡ğ‘ = 3, three poll-and-test procedures can be performed by the system (incumbent plus two other queues). If none of these results in identifying a nonempty queue, the system goes into contention over the next ğ‘‡ğ‘ = 4 minislots.
scheduling the same queue over consecutive sets of ğ¾ slots. In Sec. 11.12 in the Appendix, we show how the above scheduler can be modiï¬ed to handle Channel Errors and Fading.
5 Mechanisms for Decentralized Scheduling
We concluded Sec. 3 by providing a mechanism by which a node can keep track of the backlog of every other node the last time the latter was allowed to transmit. Prop. 1, shows that delay optimal policies with a centralized scheduler are non-idling and exhaustive in nature. Motivated by this result we will propose (in Sec. 6) a decentralized protocol that switches to a new queue only when the current one is empty. This immediately obviates the need to know anything more than the empty-nonempty status of the queues. In this section, we describe mechanisms by which this information can be obtained by the nodes in the system without any explicit exchange of information.
Transmission sensing: We assume that all nodes transmit at the same ï¬xed power, and the maximum internode distance is such that every other node can sense the power from a transmitting node. Suppose a node has been scheduled to transmit in a slot. Then, whether or not the node actually transmits can be determined by the other nodes by averaging the received power over a small interval, akin to the CCA mechanism [Kin01]. For reliable assessment, the slot will need to be of a certain length, and the distance between the nodes will need to be limited. Let such an activity sensing slot be called a minislot (Fig. 7) [RWA+08].
The sensing mechanism and these minislots can be used by all nodes to infer if the incumbent is empty. If it is, with the updated common information, another node can be immediately scheduled, thereby possibly preventing the wastage of the slot. This can be viewed as a â€œschedule-and-testâ€ mechanism. If, say ğ‘‡ğ‘ minislots are available, then ğ‘‡ğ‘ poll-and-test procedures can be done at the beginning of a slot (see Fig. 7). In a light traï¬ƒc setting, all the poll-and-test procedures might fail, with high probability. Having a large value of ğ‘‡ğ‘ reduces this probability but increases the overhead. So, the next mechanism is contention, for which we have ğ‘‡ğ‘ (â‰¥ 0) minislots following the poll-and-test slots. The nodes that have not been polled can contend over these ğ‘‡ğ‘ minislots, hopefully leading to the identiï¬cation of one non-empty queue. Fig. 8 illustrates this mechanism for a simple system with ğ‘‡ğ‘ = 1 and ğ‘‡ğ‘ = 0. In the ï¬rst slot in the ï¬gure, the absence of power indicates, to all nodes in the network, that Node 1 is now empty and Node 2 is allowed to transmit. Since Node 2 is also empty, and since no more poll-and-test procedures are possible (since ğ‘‡ğ‘ = 1), the slot is wasted. Note that if ğ‘‡ğ‘ = 2, and ğ‘‡ğ‘ â‰¥ 1, sensing that Node 2 is empty, the other nonempty nodes in the network will contend for the slot.
17

Figure 8: A sample path illustrating how cyclic exhaustive service, i.e. ğœ‹âˆ—, is implemented in a system with ğ‘‡ğ‘ = 1 and ğ‘‡ğ‘ = 0. Of particular note is the initially wasted slot. Since the poll-and-test did not identify any nonempty queue and since the system cannot go into contention (ğ‘‡ğ‘ = 0), the slot is wasted.
6 Protocol Design
In this section, we develop the two protocols EZMAC and QZMAC. We ï¬rst show how a simple modiï¬cation of the contention mechanism in ZMAC results in signiï¬cant gains in terms of delay and use that observation to design EZMAC. We then use the results in Sec. 4 to motivate the practical design of QZMAC. This section will clearly describe how the optimal polling schemes in Section 4.2 are implemented in a distributed manner which will establish the self-organizing nature of our protocols.
6.1 The EZMAC Protocol
We explain the limitations of ZMAC and propose another protocol that we call EZMAC to alleviate them.
6.1.1 The ZMAC protocol [RWA+08]
As mentioned before, ZMAC ï¬rst sets up a TDMA schedule allotting a slot to every queue in a cyclicallyrepeating frame, so ğ‘ nodes in the system means a frame with ğ‘ slots. Slot ğ‘—, 1 â‰¤ ğ‘— â‰¤ ğ‘, in every frame is assigned to Node ğ‘— which is called the Primary User (PU) in this slot. The other (ğ‘ âˆ’ 1) nodes, i.e., nodes 1, 2, Â· Â· Â· , ğ‘— âˆ’ 1, ğ‘— + 1, Â· Â· Â· , ğ‘, are called Secondary Users (SUs) in this slot. These SUs are allowed to contend for transmission rights in every TDMA slot with an empty PU. This is accomplished as follows. At the beginning of each time slot, each queue checks if it has a packet. If it does, and this is its TDMA slot (which means it is the PU), it proceeds to transmit the packet. If the current slot is NOT its TDMA slot, the queue ï¬rst checks if the PU is transmitting (for a period of 1 minislot). If it hears nothing, it backs oï¬€ over a duration chosen uniformly randomly over {ğ‘‡ğ‘ + 1, Â· Â· Â· , ğ‘‡ğ‘ + ğ‘‡ğ‘ }, and if the channel is clear, starts transmitting. Collisions are assumed to be detected instantaneously and that slot is assumed wasted. Note that a mechanism is needed to set up the TDMA schedule before transmissions can begin (ZMAC uses DRAND for this [RWMX06]). In short, ZMAC proceeds as in Protocol 1.
We are now in a position to demonstrate the importance of the results obtained in Sec. 4.5. ZMAC uses a simple TDMA system that schedules queues only once every ğ‘ slots. While TDMA is certainly stabilizing in symmetric systems, it is far from delay optimal. Fig. 9 shows how ğœ‹âˆ— shows enormous improvement over ZMAC at moderate and high loads. The two curves crossover near ğœ† = 0.775. At these arrival rates, since many queues are nonempty, hitting empty queues proves very costly to the system (in terms of delay). This is because many queues contend during the contention portion of ZMAC (the ğ‘‡ğ‘ minislots) diminishing chances of a winner ever emerging. Since TDMA polls a new queue in every slot, it ends up scheduling many empty queues incurring high delay that cannot be mitigated by contention.
18

Protocol 1 ZMAC

1: Input: ğ‘, ğ‘‡ğ‘

âŠ² QZMAC runs in parallel at every Queue ğ‘—, ğ‘— âˆˆ [ğ‘] in the network

2: Init: ğ‘¡ â† 0, ğœ â† 1, ğ‘ƒğ‘ˆ â† 1

âŠ² ğœ keeps track of the minislot number

3: while ğ‘¡ â‰¥ 0 do

ğœâ†1

âŠ² Keeps track of minislot number.

4: if ğ‘ƒğ‘ˆ == ğ‘— && ğ‘„ ğ‘— (ğ‘¡) > 0 then

âŠ² If you are the PU

5:

Tx pkt.

6:

GOTO 16

7: else

âŠ² PU empty â‡’ network enters contention

8:

Over ğœ âˆˆ {2, 3, Â· Â· Â· , ğ‘‡ğ‘ + 1} do

9:

if ğ‘„ ğ‘— (ğ‘¡) > 0 then

10:

ğ‘ˆ ğ‘— âˆ¼ ğ‘ˆğ‘›ğ‘– ğ‘“ ({2, 3, Â· Â· Â· , ğ‘‡ğ‘ + 1})

11:

Wait for ğ‘ˆ ğ‘— âˆ’ 1 minislots.

12:

If CCA == SUCCESS, Tx Pkt.

13:

GOTO 16

14:

end if

15: end if

16: ğ‘ƒğ‘ˆ â† ğ‘ƒğ‘ˆ mod ğ‘ + 1

17: ğ‘¡ â† ğ‘¡ + 1

âŠ² Next time slot

18: end while

Getting back to the development of EZMAC, consider the contention mechanism in isolation. If the contention winner can retain rights to access the channel for exactly one slot (which is what happens in ZMAC), each time the PU is empty, contention is needed to decide the next winner. We shall, henceforth, refer to the contention mechanism that allows a contention winner to transmit only in one slot as â€œALOHA.â€ That ALOHA wastes a lot of slots in contention is clearly demonstrated in the large diï¬€erence in delay in Fig. 10. This problem is solved as follows.
The proposed protocol EZMAC diï¬€ers from ZMAC in the contention resolution (CR) portion. Here, once the winner of a contention is determined, it is allowed to transmit in all slots without a PU until it empties. It is assumed that at the end of the winnerâ€™s transmission, the packet contains an end of transmission message (a bit in the header, perhaps) that can be decoded by the other users. Following the terminology in the literature ( [HK83], for example), we refer to the contention mechanism that allows a contention winner to transmit until it is empty, â€œRALOHA,â€ which stands for ALOHA with Reservation. Also, when referring to either EZMAC or QZMAC, we will redeï¬ne the term SU to refer to the queue that has won the latest

Homogeneous System with 30 queues 600

Mean Delay (slots)

500

Centralized Full knowledge

Cyclic Exhaustive Service (Ï€*)

ZMAC

400

TDMA

300

200

100

0

0

0.2

0.4

0.6

0.8

1

Total Arrival Rate (packets/slot)

Figure 9: Comparing ğœ‹âˆ— and ZMAC in a symmetric system with 30 queues. The total arrival rate to the system = ğ‘ ğœ† âˆˆ [0, 1).

19

Expected Delay (slots)

Collocated system with 10 queues 2.8

2.6

2.4

ALOHA

2.2

RALOHA

2

1.8

1.6

1.4

1.2

1

0.8

0

0.01 0.02 0.03 0.04 0.05 0.06 0.07 0.08

Î» (pkts/slot)

Figure 10: Mean delay with ALOHA and RALOHA in a symmetric system with 10 queues.

contention. EZMAC modiï¬es Steps 7-14 of ZMAC to At time slot ğ‘¡:
1. If PU is empty, check if the current SU is nonempty. If so schedule it for transmission.
2. If not, begin contention as described in the beginning of Sec. 6.1. Suppose there is no collision and a new SU, say ğ‘˜, emerges, schedule ğ‘˜ for transmission. This will remain the SU until it becomes empty.
If the current slot is not the userâ€™s TDMA slot, it checks if the PU is transmitting. If not and if the SU is also empty, the user contends for access to the channel as described above. The winner keeps transmitting in all slots where the PU is empty, until it is itself empty. Thereafter, in the next slot with an empty PU, contention begins to determine the next SU.

6.2 The QZMAC protocol
In section 4.5.2 we proved that in symmetric systems, scheduling the queue that has not been served the longest and serving it exhaustively is delay optimal. Recall that Thm. 4 therein, assumed ğ‘‡ğ‘ = 1. However, we use this result to propose a scheduling protocol, QZMAC, for general ğ‘‡ğ‘, and later show through simulations that violating the ğ‘‡ğ‘ = 1 assumption does not hurt the performance of QZMAC. Solving the MDP for general ğ‘‡ğ‘ turns out to be a hard problem and, as simulation results in ï¬gures 13a and 13b show, cannot result in any dramatic improvement in delay. We now describe QZMAC for ğ‘‡ğ‘ = 3 minislots. Every queue maintains its own copy of a vector V(ğ‘¡) that is used to render the scheduling process fully distributed. The protocol proceeds as in Algorithm. 2.
There are three points to note here. Firstly, QZMAC has clearly been obtained by separately optimizing polling and contention protocols. Jointly optimizing both turns out to be intractable and even separate optimization ultimately shows excellent delay performance. Secondly, note that depending on the value of ğ‘‡ğ‘ QZMAC can show a range of behavior. When ğ‘‡ğ‘ = 1, the system never enters contention since one minislot is spent in ascertaining that the incumbent is empty and thereafter, ğ‘–âˆ— is allowed to transmit. Determining that ğ‘–âˆ— is empty requires another minislot which is not available since ğ‘‡ğ‘ = 1, and the system can enter contention only when ğ‘–âˆ— and the SU are empty.
So, in order for the system to enter contention, QZMAC needs ğ‘‡ğ‘ = 3 (one each for the PU, ğ‘–âˆ— and the SU). Similarly, ZMAC requires ğ‘‡ğ‘ = 1 and EZMAC requires ğ‘‡ğ‘ = 2. Finally, as mentioned in Sec. 4.5.3, the use
20

Protocol 2 QZMAC (with ğ‘‡ğ‘ = 3 minislots),

1: Input: ğ‘, ğ‘‡ğ‘

2: Init: ğ‘¡ â† 0, ğœ â† 1, ğ‘ƒğ‘ˆ â† 1, ğ‘†ğ‘ˆ â† 2

3: Init: âˆ€ ğ‘˜ âˆˆ [ğ‘], ğ‘‰ğ‘˜ (0) â† ğ‘˜

4: while ğ‘¡ â‰¥ 0 do

ğœâ†1

5: if ğ‘ƒğ‘ˆ == ğ‘— && ğ‘„ ğ‘— (ğ‘¡) > 0 then

6:

ğ‘ƒğ‘ˆ transmits packet.

7:

for ğ‘˜ = 1 : ğ‘ do

8:

ğ‘‰ğ‘˜ (ğ‘¡) â† (ğ‘‰ğ‘˜ (ğ‘¡) + 1) I{ğ‘˜â‰ ğ‘ƒğ‘ˆ }

9:

end for

10:

GOTO 35

11: else

12:

ğœ â† ğœ+1

13:

ğ‘–âˆ— := ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥ğ‘–âˆˆ[ğ‘ ]ğ‘‰ğ‘– (ğ‘¡)

14:

ğ‘ƒğ‘ˆ â† ğ‘–âˆ—

15:

if ğ‘–âˆ— == ğ‘— && ğ‘„ğ‘–âˆ— (ğ‘¡) > 0 then

16:

ğ‘ƒğ‘ˆ transmits packet.

17:

for ğ‘˜ = 1 : ğ‘ do

18:

ğ‘‰ğ‘˜ (ğ‘¡) â† (ğ‘‰ğ‘˜ (ğ‘¡) + 1) I{ğ‘˜â‰ ğ‘ƒğ‘ˆ }

19:

end for

20:

GOTO 35

21:

else if ğ‘†ğ‘ˆ == ğ‘— && ğ‘„ğ‘†ğ‘ˆ (ğ‘¡) > 0 then

22:

ğœ â† ğœ+1

23:

ğ‘†ğ‘ˆ transmits packet.

24:

GOTO 35

25:

else

26:

Over ğœ âˆˆ {4, 5, Â· Â· Â· , ğ‘‡ğ‘ + 3} do

27:

if ğ‘„ ğ‘— (ğ‘¡) > 0 then

28:

ğ‘ˆ ğ‘— âˆ¼ ğ‘ˆğ‘›ğ‘– ğ‘“ ({4, 5, Â· Â· Â· , ğ‘‡ğ‘ + 3})

29:

Wait for ğ‘ˆ ğ‘— âˆ’ 4 minislots.

30:

If CCA == SUCCESS, Tx pkt.

31:

If no collisions detected, ğ‘†ğ‘ˆ â† ğ‘—

32:

end if

33:

end if

34: end if

35: ğ‘¡ â† ğ‘¡ + 1

36: end while

âŠ² This runs at every Queue ğ‘—, ğ‘— âˆˆ [ğ‘] in the network âŠ² ğœ keeps track of the minislot number âŠ² Keeps track of minislot number. âŠ² If you are the PU
âŠ² The 2nd of ğ‘‡ğ‘ minislots
âŠ² The last ğ‘‡ğ‘ minislot âŠ² SU empty â‡’ network enters contention âŠ² Queue ğ‘— knows its own backlog exactly in each slot
âŠ² Next time slot

of the V(ğ‘¡) vector automatically induces a cyclic schedule. This is a much simpler technique than DRAND, used in ZMAC [RWMX06], which involves several rounds of communication among the nodes to converge to a TDMA schedule, even for fully connected interference graphs.

7 Extending QZMAC
QZMAC was developed in Sec. 6.2as a hybrid of certain polled and random access protocols, in symmetric systems, i.e., with applications that generate data at the same rate. In this section, we show how this
21

protocol can be modiï¬ed to handle a variety of diï¬€erent applications. We begin by lifting this assumption on symmetry.
7.1 Handling Unequal Arrival Rates
Prop. 2 helps generalize QZMAC very easily to accommodate unequal arrival rates. The system only needs to choose ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥1â‰¤ğ‘–â‰¤ğ‘ ğœ†ğ‘–ğ‘‰ğ‘– (ğ‘¡) in Step 13 of QZMAC. In Sec. 9.1 we discuss distributed implementation and eï¬€ects of distributed arrival rate estimation.
7.2 Handling CCA errors
We have, hitherto, assumed that when a network queue tests for channel activity (or lack thereof), the test always succeeds. In real wireless sensor networks this operation, called a Clear Channel Assessment (CCA), involves a hypothesis test based on noisy samples of channel activity and hence, is susceptible to error. This makes a 100% success rate a strong assumption and we relax it in this section. Notice that crucially, CCA errors tamper with the ï¬delity of the V(ğ‘¡) vector across nodes and we now have a matrix ğ‘‰ğ‘ Ã—ğ‘ (ğ‘¡) = [V1 (ğ‘¡), V2 (ğ‘¡), Â· Â· Â· , Vğ‘ (ğ‘¡)], where Vğ‘– (ğ‘¡) is the local copy at Queue ğ‘–.
Extensive experimentation (reported in Sec. 8) reveals that absence of activity on the channel can be detected without error. This means that whenever a queue that is supposed to transmit (incumbent, ğ‘–âˆ— = ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥ğ‘–âˆˆ[ğ‘ ]ğ‘‰ğ‘– (ğ‘¡) or the SU) is empty, all CCAs across the network in that minislot report a â€œclear channel.â€ In detection theoretic parlance, the probability of a false alarm is zero, i.e., ğ‘ğ¹ ğ´ = 0. On the other hand, our observation is (see Sec. 8) that the probability of CCA declaring an â€œactiveâ€ channel as â€œclearâ€ is not zero, i.e., ğ‘ğ‘šğ‘–ğ‘ ğ‘  > 0. However, our experiments show that ğ‘ğ‘šğ‘–ğ‘ ğ‘  â‰ˆ 3 Ã— 10âˆ’6, i.e., CCA miss is a rare event. In Sec. 11.14 in the Appendix, we list the diï¬€erent types of misalignment that such errors can produce across the columns of the aforementioned ğ‘‰ (ğ‘¡) matrix of which only the category termed M2 therein, necessitates modiï¬cations to QZMAC. A misalignment of type M2 occurs when the ğ‘–âˆ— Node assumes that the incumbent is empty and, being nonempty, begins transmitting. Naturally, the transmissions from the two nodes collide persistently, and further provisions are now required within QZMAC to extricate the network from this state. The polling portion is modiï¬ed as follows. We set a threshold ğ¾ğ‘¡â„ğ‘Ÿ such that any time the transmitting node(s) perceive ğ¾ğ‘¡â„ğ‘Ÿ time outs, the node(s) assume it is due to CCA errors. These transmitting nodes then enter a state we term â€œCOLLâ€ and Subroutine 3 is triggered. Informally, the subroutine does the following.
1. Until the transmitting nodes receive a reset beacon (denoted RSTBCN), the ï¬rst ğ‘‡ğ‘ minisolt of every slot following the ğ¾ğ‘¡â„ğ‘Ÿ timeouts is â€™BUSYâ€™, ensuring no other queues attempt transmissions during those slots.
2. In every such slot, the transmitting nodes perform a random backoï¬€ and transmit a RESET RQST packet to the base station.
3. Upon reception of a RESET RQST packet, the Base Station broadcasts a RESET beacon.
The network then simply resets, i.e., the copy of the vector V(ğ‘¡) at each node is reset (without jettisoning any existing packets) and the protocol starts afresh. Note that while only the nodes in a COLL state trigger a reset (Steps 3-14), all nodes are required to reset their copies of the V(ğ‘¡) vector upon receiving a RESET beacon from the Base Station (Steps 15-17). As simulation results in Sec. 11.14 show, this simple modiï¬cation resolves the CCA problem but does not harm delay performance adversely.
22

Protocol 3 RESET (Subroutine)

1: Input: THRSLD, NDST, RSTBCN

2: Init: RSTBCN == FALSE âŠ² Keeps track of whether a RESET beacon has been received from the BS.

3: if NDST == COLL then

âŠ² Network resetting involves only colliding nodes.

4: while NDST == COLL && RSTBCN == FALSE do

5:

Tx DUMMY PKT

âŠ² To jam all ğ‘‡ğ‘ minislots.

6:

Over ğœ âˆˆ {4, 5, Â· Â· Â· , ğ‘‡ğ‘ + 3} do

7:

ğ‘ˆ ğ‘— âˆ¼ ğ‘ˆğ‘›ğ‘– ğ‘“ ({4, 5, Â· Â· Â· , ğ‘‡ğ‘ + 3})

8:

Wait for ğ‘ˆ ğ‘— âˆ’ 4 minislots.

9:

If CCA = SUCCESS, Tx RSTRQST pkt

âŠ² Tx a Reset Request to the BS.

10:

if RSTBCN == TRUE then

âŠ² The BS transmits a RESET beacon.

11:

NDST â† NOCOLL

12:

end if

13: end while

14: end if

15: if RSTBCN == TRUE then

âŠ² Every node in the network resets.

16: âˆ€ğ‘˜ âˆˆ [ğ‘], ğ‘‰ğ‘˜ (ğ‘¡) â† ğ‘˜ .

17: end if

Figure 11: The QZMAC testbed setup. Here, the center node is the Border Router for the network. The other nodes, numbered 1 to 4, are the sensor nodes. These nodes are programmed to run the QZMAC protocol and transmit packets to the Border Router.
8 Experiments on an Implementation of QZMAC
We implement the QZMAC algorithm as an additional module in the MAC layer of the 6TiSCH communication stack under the Contiki operating system [DGV04]. With the aid of in-built Contiki-based APIs, we implemented diï¬€erent wireless transceiver functionalities and carried out our experiments over Channel 15 of the 2.4 GHz ISM band. We deployed CC2420 based telosB motes placed equidistant from the receiver node on a circular table Fig. 11. Here, the node placed in the center acts as a â€œBorder Routerâ€ (BR). The BR is always connected to a PC (host) through a USB cable; the BR collects the data packets from the sensor nodes and sends them to the host, which can further route them to the data processing computer over the Internet. Nodes labeled 1 to 4 in Fig. 11 are the sensor nodes upon which QZMAC runs. Our experiments aim to study the following aspects:
â€¢ The network infers and maintain the status of V vector based on empty and non empty status of sensor nodes.
23

â€¢ Verify the protocol working in contention mode as described between step 25 and step 33 of the QZMAC
â€¢ CCA status inference across the slots
â€¢ Synchronization within the network
8.1 Frame Structure: Time Slots and Mini-Slots
Time Slotted Channel Hopping (TSCH) is a MAC layer speciï¬ed in the IEEE 802.15.4-2015 [iee16] standard, with a design inherited from WirelessHART and ISA 100.11a standards. In our implementation, we used the slots deï¬ned as part of TSCH within Contiki (sans the channel hopping utility). The duration of a time slot is 10ğ‘šğ‘  which is suï¬ƒciently long for the transmitter to transmit the longest possible packet and for the receiver to return an acknowledgment. The slots are further divided into polling minislots and contention minislots as shown in Fig. 7. The minislots are of two standard Clear Channel Assessment (CCA) duration, where 1 CCA duration is 128 microseconds. In our experiments, we used 3 polling and 9 contention minislots i.e. ğ‘‡ğ‘ = 3, and ğ‘‡ğ‘ = 9.
8.2 Time Synchronization
Maintaining network-wide time synchronization at the level of the minislots is a nontrivial problem. For our experiments, we used the Adaptive Synchronisation Technique [CWPW15]. The Border Router periodically broadcasts Enhanced Beacons (EBs) containing a ï¬eld indicating the current slot number also known as Absolute Slot Number (ASN). The other nodes store the ASN value and increment it every slot to keep the time slot number aligned. To align the time slot boundaries, the ï¬rst mini-slot begins after a guard time oï¬€set of TsTxOffset from the leading edge of every slot. Every node timestamps the instant it starts receiving the EB, and then aligns its internal timers so that its slot starts exactly TsTxOffset before the reception of EB. In our implementation we used TsTxOffset=1.8ms. Through extensive experimentation, we veriï¬ed that clock drifts were not aï¬€ecting the protocolâ€™s working across the minislots. The nodes form a 1-hop fully connected network. We used the â€œRouting Protocol for Low-Power and Lossy Linksâ€ (RPL) to form the routes within the network [W+12] and veriï¬ed the working of our ï¬rmware on the COOJA simulator [ODE+06], before compiling it on to real target motes. We now describe our experimentation methodology in detail.
8.3 CCA Errors : Inference and Handling
To study the eï¬€ect of CCA errors on our protocol, we set up two testbeds (similar to the one in Fig. 11) with network diameter 6 meters and 8 meters respectively, each running QZMAC for a period of 12 hours (i.e., 3 Ã— 106 time slots). The sensor nodes were programmed to generate packet at constant rate ensuring the queue at sensor nodes are always non empty and transmit as per the protocol. One of the sensor nodes was connected to a terminal and designated to monitor the CCA status during the experiment. Over the course of our experiment, we observed 1 CCA â€œMissâ€ error on the testbed with 6 m network diameter and, on the network with 8 m diameter, we recorded 3 CCA â€œMissâ€ errors, both calculated over a period of 12 hours. No False Alarms were observed. Further, in any given time slot at most one CCA error occurred network-wide.
24

9 Experimental Results
We now report the results of our extensive implementation and simulation studies of the various algorithms proposed in the earlier sections. We also deal with practical issues, such as arrival rate estimation and channel utilization. We begin with the performance of the LEQ algorithm proposed in Sec. 4.3. Protocols such as ZMAC [RWA+08] and subsequent developments such as [DNF+05], [AHM+06] and [SSB10] have not been designed to address the issue of unequal arrival rates. These protocols are not capable of stabilizing queues in this general setting, let alone provide low delay. Furthermore, the rigid cyclic TDMA structure imposed by the slot assignment protocol prevents extension to unequal arrival rates.
To the best of our knowledge, this is the ï¬rst work that deals with hybrid MAC scheduling for systems with unequal arrival rates. Consequently, we do not have any hybrid algorithms against which to compare the LEQ policy. The ZMAC protocolâ€™s cyclic TDMA schedule assigns a single slot to each queue in one TDMA frame and hence is not Throughput Optimal. Furthermore, computing even an approximately delay optimal TDMA schedule requires complete knowledge of the arrival rate vector and even then requires prohibitively high message passing between nodes. One such procedure is given in [HR87]. It can be seen that the lower bound on delay even within the class of cyclic TDMA policies cannot always be achieved by this method; one example is when the arrival rates are irrational. Moreover, the general problem of ï¬nding the periodic TDMA schedule of minimum length is NP-complete [AAKD08]. We, therefore, provide comparisons only with the lowest delay that can be achieved in this system, i.e., the one with a centralized scheduler that schedules a non empty queue in every slot.
9.1 Distributed Implementation of the LEQ policy
In the LEQ policy, keeping track of the vector V(ğ‘¡) is simple. Each queue simply needs to maintain a count of the number of departures before the queue in service empties. But the arrival rates are a diï¬€erent issue altogether. Clearly, ï¬nding ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥1â‰¤ğ‘–â‰¤ğ‘ ğœ†ğ‘–ğ‘‰ğ‘– (ğ‘¡) in every scheduling slot requires knowledge of the entire arrival rate vector ğ€. Arrival rate estimation might not be feasible in several sensor networks of today that are expected to begin performing as soon as they are installed. For more information about this â€œpeel and stickâ€ paradigm refer to [DWVT14].
We resolve this problem by ï¬rst observing that under stability, the time average of the total number of packets transmitted by any queue tends to the arrival rate. Let ğ·ğ‘– (ğ‘¡) be the random variable that denotes whether or not a departure occurred from queue ğ‘– at the end of slot ğ‘¡. Then, under stability, limğ‘‡ â†’âˆ ğ‘‡1 ğ‘‡ğ‘¡=0 ğ·ğ‘– (ğ‘¡) = ğœ†ğ‘–, ğ‘.ğ‘ . So, let ğœ†Ë†ğ‘– (ğ‘‡ ) := ğ‘‡1 ğ‘‡ğ‘¡=0 ğ·ğ‘– (ğ‘¡). The policy that chooses ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥1â‰¤ğ‘–â‰¤ğ‘ ğœ†Ë†ğ‘– (ğ‘¡)ğ‘‰ğ‘– (ğ‘¡) in every scheduling slot also shows the same mean delay performance as the LEQ policy, as evidenced by simulation results presented below. This estimate can be maintained independently at each queue and the resulting decisions are still consistent. In Fig. 12a and Fig. 12b, we show the delay performance of QZMAC which takes decisions based on exact knowledge of arrival rates and the distributed version that only uses estimates of arrival rates. The green and red curves, corresponding to scheduling with estimated and exact arrival rates respectively, overlap signiï¬cantly, showing that arrival rate estimation does not degrade performance. Moreover, in small systems (Fig. 12a), the delay is almost the lowest that can be achieved, while with larger systems, the diï¬€erence with the centralized schedulerâ€™s delay becomes non negligible only near saturation.
With QZMAC, the nodes need to ï¬rst determine that the incumbent is empty, followed by detecting if the LEQ is empty and ï¬nally, if the current contention winner is empty before entering contention mode. Since each of these requires 1 minislot, QZMAC uses ğ‘‡ğ‘ = 3 minislots and ğ‘‡ğ‘ = 7 minislots and ğ‘‡ğ‘ + ğ‘‡ğ‘ = 10. We will need to keep this total number of minislots the same for all protocols whose performances we compare (in Sec. 9.2) to ensure that the fraction of time per slot allocated to scheduling decisions (and not packet
25

transmission) is the same in all protocols being studied. Simulations are performed with ğ‘ = 10 and 30 nodes. In either case, we see that both protocols show the same delay performance. While in small systems (10 queues), the protocol very nearly hits the delay lower bound (with less than 1 slot delay diï¬€erence near saturation), in large systems (30 queues) near saturation, the diï¬€erence is larger (approximately 32% increase).

Expected Delay (slots) Expected Delay (slots)

System with 10 queues (unequal arrival rates) 40

35

Centralized full knowledge

30

QZMAC (LEQ computed with exact arrival rates)

QZMAC (LEQ computed with estimated arrival rates)

25

20

15

10

5

0 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1
Î£iÎ»i (pkts/slot)
(a) System with 10 queues.

System with 30 queues (unequal arrival rates) 70

60

Centralized full knowledge

50

QZMAC (LEQ computed with exact arrival rates)

QZMAC (LEQ computed with estimated arrival rates)

40

30

20

10

0

0

0.2

0.4

0.6

0.8

1

Î£iÎ»i (pkts/slot)

(b) System with 30 queues.

Figure 12: Performance of QZMAC with exact and estimated arrival rates (ğ‘‡ğ‘ = 3 and ğ‘‡ğ‘ = 7).

9.2 Performance of EZMAC and QZMAC

With Bernoulli arrivals to each queue, the centralized full knowledge scheduler converts the system into a ğºğ‘’ğ‘œ[ğ‘¥]/ğ·/1 queue. In every slot, the arrivals to this queue are distributed according to a Binomial(ğ‘, ğœ†) distribution, where ğœ† âˆˆ [0, 1/ğ‘) is the common arrival rate to all queues. This queue can be analysed for expected delay ğ‘Š (ğœ†) [BK93], and we get:

2 âˆ’ (ğ‘ + 1)ğœ†

ğ‘Š (ğœ†) =

.

(14)

2(1 âˆ’ ğ‘ğœ†)

We compare all protocols against this lower bound.

We ï¬rst consider a system with equal arrival rates and compare the performance of QZMAC with that of the ğºğ‘’ğ‘œ[ğ‘‹ ]/ğ·/1 queue as described in (14), ZMAC and EZMAC. We see from ï¬gures 13a and 13b, that the delay achieved by QZMAC is very close to optimal as is that achieved by EZMAC. In Fig. 13a, the ğºğ‘’ğ‘œ[ğ‘¥]/ğ·/1 queue delay cannot be seen explicitly since QZMAC performs almost exactly like it. This is quite encouraging since QZMAC only needs knowledge of the time since a queue was served last, while the optimal algorithm needs full queue-length knowledge at all times. With 30 queues, in fact, QZMAC shows a decrease in delay over ZMAC of more than 60% and EZMAC of more than 40%. Note that since QZMAC requires ğ‘‡ğ‘ = 3, in order to keep the scheduling portionâ€™s length ğ‘‡ğ‘ + ğ‘‡ğ‘ constant so as to maintain the scheduling portion to transmission portion (see Fig. 7) fraction uniform across protocols, we have reduced the contention window size by three minislots while simulating QZMAC. Also, as the ï¬rst ï¬gure shows, for low and moderate arrival rates, in small WSNs one can use EZMAC and still achieve good delay performance.

9.3 Tuning QZMAC
One can tune QZMAC by changing ğ‘‡ğ‘ and ğ‘‡ğ‘ keeping ğ‘‡ğ‘ +ğ‘‡ğ‘ = ğ‘, a constant. As the number of slots reserved for polling, ğ‘‡ğ‘ increases, Fig. 14 shows that QZMAC with fewer polling slots initially performs better, but at
26

Expected Delay (slots) Expected Delay (slots)

Symmetric system with 10 queues 200

150 Geo[x]/D/1 QZMAC

EZMAC

ZMAC

100

TDMA

50

0

0

0.02

0.04

0.06

0.08

0.1

Î» (pkts/slot)

(a) System with 10 queues.

600 500 400 300 200 100
0 0

Symmetric system with 30 queues
Geo[x]/D/1 QZMAC EZMAC ZMAC TDMA

0.005 0.01 0.015 0.02 0.025 0.03 Î» (pkts/slot)
(b) System with 30 queues.

0.035

Figure 13: Expected delay with QZMAC, ZMAC and EZMAC. The systems have 10 queues 13a and 30 queues 13b. ğ‘‡ğ‘ = 9 for ZMAC and 8 for EZMAC. For QZMAC, ğ‘‡ğ‘ = 7.

Expected Delay (slots)

Symmetric system with 30 queues 5

4.5

4

QZMAC T =3
p

QZMAC T =8

p

3.5

ZMAC

3

2.5

2

1.5

1

0

0.005

0.01

0.015

0.02

0.025

0.03

Î» (pkts/slot)

Figure 14: Figure showing how QZMAC can be tuned. Keeping ğ‘‡ğ‘ + ğ‘‡ğ‘ ï¬xed at 10 minislots, increasing ğ‘‡ğ‘ causes delay to increase at light loads and decrease at heavy loads.

high loads, is overtaken by QZMAC with fewer slots for contention. At arrival rates close to 0 (i.e., ğœ† â‰ˆ 0), it is an SU that transmits during most slots. This is because, with high probability, the PUâ€™s are empty and the protocol enters the contention portion. Clearly, higher the value of ğ‘‡ğ‘, greater the probability of resolving this contention. But at high loads (ğœ† â‰ˆ 1 ) the PUâ€™s are nonempty with high probability and
ğ‘
hence, the polling portion is more likely to yield a nonempty queue. With a higher value of ğ‘‡ğ‘, a nonempty queue can be found and the system does not have to go into contention. This trend is expected and opens up avenues for further research about protocols that automatically choose the â€œrightâ€ ğ‘‡ğ‘ and ğ‘‡ğ‘ given that the fraction of time occupied by the scheduling portion must not exceed some predetermined threshold.
We simulated all three algorithms (QZMAC, EZMAC and ZMAC) once again, in symmetric systems and computed the (empirical) cumulative distribution functions (CDFs) of system backlog with all three (and basic TDMA as an upper bound). As Fig. 15 clearly shows, QZMAC indeed provides the stochastically smallest sum queue lengths, followed by EZMAC (owing to its superior contention mechanism) and ï¬nally ZMAC. TDMA, as expected, performs the worst. With QZMAC, the CDF hits 1 at 12 packets, while its closest competitor, EZMACâ€™s CDF has a support that extends until 69 packets and that of ZMAC extends to 220 packets.

27

CDF

Symmetric system with 30 queues (Î» = 0.032) 1

0.9

0.8

0.7

ZMAC

0.6

EZMAC

0.5

QZMAC

TDMA

0.4

0.3

0.2

0.1

0

0

50

100

150

200

250

Queue Length

Figure 15: The CDFs of total system backlog with QZMAC, EZMAC, ZMAC and TDMA.

9.4 Channel Utilization

Recall from our earlier discussion (see Prop. 1) that the optimal scheduling policy under the information structure assumed in this paper lies in the class of non-idling, exhaustive policies. Consequently, the more eï¬ƒciently a MAC algorithm ï¬nds non empty queues in the network (assuming there are packets in the network), the better its mean delay performance is likely to be. In the literature, this probability of a non empty queue being served when one exists in the network is termed Channel Utilization, (ğœ) and is a performance metric commonly used to compare the eï¬ƒciency of MAC algorithms [RWA+08,WR05]. Formally, given a scheduling policy ğœ‹,

ğ‘

ğ‘

âˆ‘ï¸

âˆ‘ï¸

ğœ ğœ‹ (Q(0))

:=

lim

ğœ‹
PQ ( 0)

I{ğ‘„ğ‘— (ğ‘¡)>0} ğ· ğ‘— (ğ‘¡) > 0 ğ‘„ ğ‘— (ğ‘¡) > 0

ğ‘¡ â†’âˆ

ğ‘— =1

ğ‘— =1

(âˆ—) ğ‘¡ğ‘¡âˆ’=01 ğ‘ğ‘—=1 I{ğ‘„ ğ‘— (ğ‘¡)>0} ğ· ğ‘— (ğ‘¡) > 0

= lim
ğ‘¡ â†’âˆ

ğ‘¡ âˆ’1
I

, >0

ğ‘¡ =0

{

ğ‘ ğ‘—=1

ğ‘„

ğ‘—

(ğ‘¡

)

>0

}

where the (âˆ—) is under the assumption that the queue length process is ergodic. We used the setup described

in Sec. 8, to compare the channel utilization of QZMAC with that of ZMAC. Tthe network comprised 7

collocated nodes transmitting to a base station. Packet arrivals to the nodes followed IID Bernoulli processes

with rates ğ€ = [0.17, 0.20, 0.04, 0.17, 0.17, 0.02, 0.07]. This rate vector is clearly within the network capacity

region, because

7
ğ‘–=1 ğœ†ğ‘–

= 0.84 < 1.

The results of the experiment are shown in Table. 1.

The experiment

was repeated for diï¬€erent values of control overhead, i.e., the portion of the time slot wasted in scheduling

a queue (ğ‘‡ğ‘ + ğ‘‡ğ‘). The value of ğ‘‡ğ‘ was kept constant, ğ‘‡ğ‘ = 1 for ZMAC and ğ‘‡ğ‘ = 3 for QZMAC, and the

number of contention minislots was varied.

One obvious trend is that channel utilization increases as control overhead increases, since it becomes easier to resolve contention whenever it occurs with more ğ‘‡ğ‘ minislots. However, the other point to note is that regardless of contention overhead, QZMAC outperforms ZMAC. This is due to the fact that both the polling and the contention mechanisms of the former are designed better than the latter to ï¬nd non empty queues with greater probability.

28

Algorithm
ZMAC (ğ‘‡ğ‘ = 1) QZMAC (ğ‘‡ğ‘ = 3)

ğ‘‡ğ‘ + ğ‘‡ğ‘ = 7
0.88968 0.96312

ğ‘‡ğ‘ + ğ‘‡ğ‘ = 8
0.90379 0.9706

ğ‘‡ğ‘ + ğ‘‡ğ‘ = 9
0.91356 0.97486

Table 1: Comparing the channel utilization of QZMAC with that of ZMAC with varying control overhead (ğ‘‡ğ‘ + ğ‘‡ğ‘). Clearly,

ğ‘„ğ‘ ğ‘€ ğ´ğ¶
ğœ

>

ğœ ğ‘ ğ‘€ ğ´ğ¶ ,

showing

that

the

former

wastes

the

channel

less

often,

thereby

clearing

the

network

of

packets

more

eï¬ƒciently.

10 Conclusion and Future work

Our objective has been to develop distributed MAC protocols, which require minimal information sharing, for data collection from resource-challenged wireless sensors. In this paper, we ï¬rst extended some results from optimal polling to systems with limited information structures and proved the delay-optimality of exhaustive service and cyclic polling in a symmetric version of our limited information scheduling problem. Leveraging these results, we proposed two distributed protocols EZMAC and QZMAC that perform much better than those available in the literature, both with respect to mean delay and system backlog distributions. We then extended this analysis to design hybrid MACs for systems with unequal arrival rates as well. Further, we showed that delay optimality comes at the price of excessive short-term unfairness and proposed modiï¬cations to QZMAC to reduce unfairness. We then implemented QZMAC on a test bed comprising telosB motes and demonstrated the operation of several salient aspects of the protocol. In the process, we also obtained a clear understanding of the CCA performance of the motes which, in turn, allowed us to extend QZMAC to handle situations with unequal arrival rates, CCA errors and alarm traï¬ƒc. Extensions to this work will look at handling Markovian arrivals and state dependent fading. This paper handled fully-connected interference graphs. In the future, we will also be investigating how to modify QZMAC to solve the hidden node problem. Furthermore, our future study will include extending the theory we have developed in the present article to propose similar low-delay decentralized scheduling algorithms for more general interference graphs. Scheduling with energy harvesting nodes wherein the nodes are â€œawakeâ€ only for certain periods and â€œasleepâ€ otherwise is an important area for IoT applications.

References

[AAKD08]

Imtiaz Ahmad, Buthaina Al-Kazemi, and A Shoba Das. An eï¬ƒcient algorithm to ï¬nd broadcast schedule in ad hoc tdma networks. Journal of Computer Systems, Networks, and Communications, 2008:12, 2008.

[AHM+06]

Gahng-Seop Ahn, Se Gi Hong, Emiliano Miluzzo, Andrew T Campbell, and Francesca Cuomo. Funneling-MAC: a localized, sink-oriented MAC for boosting ï¬delity in sensor networks. In Proceedings of the 4th international conference on Embedded networked sensor systems, pages 293â€“306. ACM, 2006.

[AKL92]

Eitan Altman, Panagiotis Konstantopoulos, and Zhen Liu. Stability, monotonicity and invariant quantities in general polling systems. Queueing Systems, 11(1-2):35â€“57, 1992.

[Ber95]

Dimitri P Bertsekas. Dynamic Programming and Optimal Control. Number 2. Athena Scientiï¬c Belmont, MA, 1995.

[BK93]

Herwig Bruneel and Byung G. Kim. Discrete-time Models for Communication Systems including ATM. Kluwer Academic Publishers, 1993.

29

[CWPW15] Tengfei Chang, Thomas Watteyne, Kris Pister, and Qin Wang. Adaptive synchronization in multi-hop tsch networks. Computer Networks, 76:165â€“176, 2015.

[DGV04]

A. Dunkels, B. Gronvall, and T. Voigt. Contiki - a lightweight and ï¬‚exible operating system for tiny networked sensors. In 29th Annual IEEE International Conference on Local Computer Networks, pages 455â€“462, Nov 2004.

[DNF+05]

Christian Doerr, Michael Neufeld, Jeï¬€ Fiï¬eld, Troy Weingart, Douglas C Sicker, and Dirk Grunwald. MultiMAC-an adaptive MAC framework for dynamic radio networking. In New Frontiers in Dynamic Spectrum Access Networks, 2005. DySPAN 2005. 2005 First IEEE International Symposium on, pages 548â€“555. IEEE, 2005.

[DWVT14] Diego Dujovne, Thomas Watteyne, Xavier Vilajosana, and Pascal Thubert. 6tisch: deterministic ip-enabled industrial internet (of things). IEEE Communications Magazine, 52(12):36â€“41, 2014.

[EM+82]

Anthony Ephremides, Osama Mowaï¬, et al. Analysis of a hybrid access scheme for buï¬€ered users-probabilistic time division. Software Engineering, IEEE Transactions on, (1):52â€“61, 1982.

[FL96]

Serguei Foss and GuÂ¨nter Last. Stability of polling systems with exhaustive service policies and state-dependent routing. The Annals of Applied Probability, 6(1):116â€“137, 1996.

[FMM95]

G Fayolle, V.A. Malyshev, and M.V. Menshikov. Topics in the Constructive Theory of Countable Markov Chains. 1995.

[GRC+14]

Luigi Alfredo Grieco, Alessandro Rizzo, Simona Colucci, Sabrina Sicari, Giuseppe Piro, Donato Di Paola, and Gennaro Boggia. Iot-aided robotics applications: Technological implications, target domains and open issues. Computer Communications, 54:32â€“47, 2014.

[HK83]

M Hofri and A Konheim. The Analysis of a Finite Quasi-Symmetric ALOHA Network with Reservation. Technion-Israel Institute of Technology. Department of Computer Science, 1983.

[HL89]

OnÂ´esimo HernÂ´andez-Lerma. Adaptive Control of Markov Processes. Springer Verlag New York, NY, 1989.

[HR87]

Micha Hofri and Zvi Rosberg. Packet delay under the golden ratio weighted tdm policy in a multiple-access channel. IEEE Transactions on Information Theory, 33(3):341â€“349, 1987.

[iee16]

IEEE standard for low-rate wireless networks. IEEE Std 802.15.4-2015 (Revision of IEEE Std 802.15.4-2011), pages 1â€“709, 2016.

[JCH84]

Raj Jain, Dah-Ming Chiu, and William R Hawe. A quantitative measure of fairness and discrimination for resource allocation in shared computer system, volume 38. Eastern Research Laboratory, Digital Equipment Corporation Hudson, MA, 1984.

[JW11]

Libin Jiang and Jean Walrand. Approaching throughput-optimality in distributed csma scheduling algorithms with collisions. Networking, IEEE/ACM Transactions on, 19(3):816â€“829, 2011.

[JW12]

Libin Jiang and Jean Walrand. Stability and delay of distributed scheduling algorithms for networks of conï¬‚icting queues. Queueing Systems, 72(1-2):161â€“187, 2012.

[Kin01]

Pat Kinney. The 802.15.4 CCA method. Project: IEEE P802.15 Working Group for Wireless Personal Area Networks (WPANs), Submitted: Nov 14, 2001.

[Le84]

Simon S Lam (editor). Principles of Communication and Networking Protocols. IEEE Computer Society Press, 1984.

30

[LNT92]

Zhen Liu, Philippe Nain, and Don Towsley. On optimal polling policies. Queueing Systems, 11(1-2):59â€“83, 1992.

[LRZ03]

Juan Liu, James Reich, and Feng Zhao. Collaborative in-network processing for target tracking. EURASIP Journal on Advances in Signal Processing, 2003(4):616720, 2003.

[Mat19]

Kayla Matthews. The internet of robotic things: How iot and robotics tech are evolving together. 2019.

[ODE+06]

F. Osterlind, A. Dunkels, J. Eriksson, N. Finne, and T. Voigt. Cross-level sensor network simulation with cooja. In Proceedings. 2006 31st IEEE Conference on Local Computer Networks, pages 641â€“648, 2006.

[RSS09]

Shreevatsa Rajagopalan, Devavrat Shah, and Jinwoo Shin. Network adiabatic theorem: an eï¬ƒcient randomized protocol for contention resolution. In ACM SIGMETRICS Performance Evaluation Review, volume 37, pages 133â€“144. ACM, 2009.

[RWA+08]

Injong Rhee, Ajit Warrier, Mahesh Aia, Jeongki Min, and Mihail L Sichitiu. Z-MAC: a hybrid MAC for wireless sensor networks. IEEE/ACM Transactions on Networking (TON), 16(3):511â€“ 524, 2008.

[RWMX06] Injong Rhee, Ajit Warrier, Jeongki Min, and Lisong Xu. DRAND: Distributed randomized TDMA scheduling for wireless ad-hoc networks. In Proceedings of the 7th ACM international symposium on Mobile ad hoc networking and computing, pages 190â€“201. ACM, 2006.

[Sen89]

Linn I Sennott. Average cost optimal stationary policies in inï¬nite state markov decision processes with unbounded costs. Operations Research, 37(4):626â€“633, 1989.

[SSB10]

Lanny Sitanayah, Cormac J Sreenan, and Kenneth N Brown. ER-MAC: A hybrid MAC protocol for emergency response wireless sensor networks. In Sensor Technologies and Applications (SENSORCOMM), 2010 Fourth International Conference on, pages 244â€“249. IEEE, 2010.

[Tak88]

Hideaki Takagi. Queuing analysis of polling models. ACM Computing Surveys (CSUR), 20(1):5â€“ 28, 1988.

[TE93]

Leandros Tassiulas and Anthony Ephremides. Dynamic server allocation to parallel queues with randomly varying connectivity. Information Theory, IEEE Transactions on, 39(2):466â€“ 478, 1993.

[TE92]

Leandros Tassiulas and Anthony Ephremides. Stability properties of constrained queueing systems and scheduling policies for maximum throughput in multihop radio networks. Auto. Ctrl., IEEE Trans. on, â€™92.

[TK85]

H. Takagi and L. Kleinrock. A tutorial on the analysis of polling systems. Technical Report UCLA Report No. 850005, Computer Science Department, UCLA, February 1985.

[TPE15]

Pascal Thubert, Maria Rita Palattella, and Thomas Engel. 6TiSCH centralized scheduling: when SDN meets IoT. In Proc. of IEEE Conf. on Standards for Communications and Networking (CSCN, 2015), 2015.

[W+12]

Tim Winter et al. Rpl: Ipv6 routing protocol for low-power and lossy networks. RFC, 6550:1â€“ 157, 2012.

[WR05]

Ajit Warrier and Injong Rhee. Stochastic analysis of wireless sensor network MAC protocols. North Carolina State Univ., Comput. Sci. Dept.,, â€™05.

31

[YG02] [YHE02] [YSB+21] [ZWX17]

Yong Yao and Johannes Gehrke. The cougar approach to in-network query processing in sensor networks. ACM Sigmod record, 31(3):9â€“18, 2002.
Wei Ye, John Heidemann, and Deborah Estrin. An energy-eï¬ƒcient mac protocol for wireless sensor networks. In INFOCOM 2002. Twenty-ï¬rst annual joint conference of the IEEE computer and communications societies. Proceedings. IEEE, volume 3, pages 1567â€“1576. IEEE, 2002.
Roy D Yates, Yin Sun, D Richard Brown, Sanjit K Kaul, Eytan Modiano, and Sennur Ulukus. Age of information: An introduction and survey. IEEE Journal on Selected Areas in Communications, 39(5), 2021.
Ray Y Zhong, Lihui Wang, and Xun Xu. An iot-enabled real-time machine status monitoring approach for cloud manufacturing. Procedia CIRP, 63:709â€“714, 2017.

Avinash Mohan (S.M. â€™16, M â€™17) obtained his Masterâ€™s degree from the Indian Institute of Technology (IIT) Madras, and his PhD from and the Indian Institute of Science (IISc) Bangalore. He is currently a postdoctoral fellow at the Technion, Israel Institute of Technology, Haifa, Israel. His research interests include stochastic control, reinforcement learning, analysis of deregulated energy markets and resource allocation in wireless communication networks.
Arpan Chattopadhyay obtained his B.E. in Electronics and Telecommunication Engineering from Jadavpur University, India in the year 2008, and M.E. and Ph.D in Telecommunication Engineering from Indian Institute of Science, Bangalore, India in the year 2010 and 2015, respectively. He was a postdoctoral researcher in the Electrical Engineering department and is currently an assistant professor at the Indian Institute of Technology, Delhi, India. His research interests include design, resource allocation, control and learning in wireless networks and cyber-physical systems.
Shivam Vinayak Vatsa (B Tech. â€™16) obtained Bachelor of Technology from NIIT University, India in Computer Science. He is currently a Software Engineer in Common Algorithm Development Group at ABB India. His research interests include Internet of Things, Cyber Physical Systems and Data analysis of wireless communication networks.
Anurag Kumar (Fellow IEEE) (B.Tech., Indian Institute of Technology (IIT) Kanpur; PhD, Cornell University, both in Electrical Engineering) was with Bell Labs, Holmdel, N.J., for over 6 years. Since then he has been on the faculty of the ECE Department at the Indian Institute of Science (IISc), Bangalore; he is at present the Director of the Institute. His area of research is communication networking, and he has recently focused primarily on wireless networking. He is a Fellow of the IEEE, the Indian National Science Academy (INSA), the Indian National Academy of Engineering (INAE), and the Indian Academy of Sciences (IASc). He was an associate editor of IEEE Transactions on Networking, and of IEEE Communications Surveys and Tutorials.

32

11 Appendices
11.1 Glossary of Notation and Acronyms
1. ğ´ ğ‘— (ğ‘¡): number of packets arriving to Queue ğ‘— in time slot ğ‘¡. 2. ğµ(ğ‘‰ğ‘— ): If ğ´ is a generic Bernoulli(ğœ†) random variable, and ğ¶ is distributed Binomial(ğ‘‰ğ‘— , ğœ†), then ğµ(ğ‘‰ğ‘— )
is a random variable whose distribution is the same as that of (ğ¶ âˆ’ 1)+ + ğ´. 3. CCA: Clear Channel Assessment. 4. ğ· ğ‘— (ğ‘¡): the number of departures from Queue ğ‘— in time slot ğ‘¡. 5. ğ»ğ‘¡ğœ‹: the history of policy ğœ‹ up to time ğ‘¡ as deï¬ned in (3). 6. Q(ğ‘¡): backlog of Queue ğ‘— at the beginning of time slot ğ‘¡. 7. ğ‘„ ğœ‹ (ğ‘¡): backlog of Queue ğ‘— at the beginning of time slot ğ‘¡ under scheduling policy ğœ‹.
ğ‘—
8. ğ¾ğ‘¡â„ğ‘Ÿ : the threshold that triggers the RESET subroutine. It is denoted by THRSLD in the subroutine description.
9. ğ€: the arrival rate vector. 10. ğš²: the capacity region of the queueing network. 11. ğš²ğ¿ğ¸ğ‘„: the set of arrival rates that the LEQ policy can stabilize. 12. [ğ‘]: the set of integers {1, 2, Â· Â· Â· , ğ‘ }. 13. NDST: is short for â€œNode State.â€ Attains values COLL (meaning â€œin collisionâ€) or NOCOLL (meaning
â€œnot in collisionâ€). 14. PU: Primary User. 15. Î : the space of all admissible policies. 16. Î ğ‘’: the subset of all exhaustive service policies. 17. Î ğ‘”: the subset of all non-idling service policies. 18. RSTBCN: Reset Beacon. 19. SU: Secondary User. In ZMAC this refers to any queue which is not the current PU. In EZMAC and
QZMAC, this refers to the queue that won the latest contention. 20. ğ‘‡ğ‘: number of minislots reserved for contention. 21. ğ‘‡ğ‘: number of minislots reserved for polling. 22. ğ‘‰ ğœ‹ (ğ‘¡): is the number of slots prior to slot ğ‘¡ in which Queue ğ‘— was allowed to transmit under a generic
ğ‘—
scheduling policy ğœ‹.
33

Q1=1, but Q2=0

Q3>0

Q4=1

Q1=1

Q6>0

Idle Slot

Service

Service

n*: Ï€ decides to switch

Q1=1

Q2=0

Q3>0

Service

Service

QÎ³ = QÏ€

m*

Q4=1

Q6>0

Service

Idle Slot

Service

Service

Service

Figure 16: A sample path illustrating how ğ›¾ is derived from ğœ‹.

11.2 Proof of Prop. 1

This proof proceeds along the lines of the proof in [LNT92, Prop. 4.2]. It is easy to show that we can restrict
attention to non-idling policies and so, we begin our proof with some policy ğœ‹ âˆˆ Î ğ‘”, where, as mentioned
in Sec. 4.1, Î ğ‘” is the set of all non-idling policies. Consider a sample path ğœ” ( a realization of the input sequences { ğ´ğ‘– (ğ‘›)}âˆğ‘›=1 , ğ‘– âˆˆ ğ¼ and on that path, let

ğ‘›âˆ— := inf

ğ‘›

â‰¥

1

:

ğœ‹
ğ‘„ğ‘

(ğ‘›)

> 0,

ğ‘„ ğœ‹ğ‘ (ğ‘›)

= 0,

and

ğ‘
ğœ‹

=2

.

(15)

ğœ‹ğ‘›âˆ’1

ğœ‹ğ‘›

ğ‘›

This is the ï¬rst instant when a time slot is wasted by ğœ‹ on account of switching to an empty queue though the previous one was non-empty. Further deï¬ne

ğ‘šâˆ— = inf ğ‘› > ğ‘›âˆ— : ğ‘„ ğœ‹ğœ‹ğ‘›ğ‘âˆ’1 (ğ‘›) > 0, ğœ‹ğ‘›ğ‘âˆ’1 = ğœ‹ğ‘›ğ‘âˆ— , and ğœ‹ğ‘›ğ‘ = 1 .

(16)

This is the ï¬rst time since ğ‘›âˆ— that the server continues to serve the (same) incumbent ï¬nding it to be non-empty. Construct another policy ğ›¾ as follows (refer to Fig.16 for an illustration).

â€¢ On [1, ğ‘›âˆ—) and [ğ‘šâˆ— + 1, âˆ), (ğ›¾ğ‘, ğ›¾ğ‘) = (ğœ‹ğ‘, ğœ‹ğ‘).

ğ‘˜ğ‘˜

ğ‘˜ğ‘˜

â€¢

(ğ›¾ğ‘âˆ— ,
ğ‘›

ğ›¾ğ‘âˆ— )
ğ‘›

=

(1,

ğœ‹ğ‘(ğ‘›âˆ—âˆ’1) ),

and

â€¢

for

ğ‘›âˆ— + 1 â‰¤

ğ‘˜

â‰¤ ğ‘šâˆ—,

(ğ›¾ğ‘, ğ›¾ğ‘)
ğ‘˜ğ‘˜

=

(

ğœ‹

ğ‘ ğ‘˜ âˆ’1

,

ğœ‹

ğ‘ ğ‘˜ âˆ’1

)

.

So, ğ›¾ follows ğœ‹ over [1, ğ‘›âˆ—) and [ğ‘šâˆ— + 1, âˆ) and at ğ‘›âˆ—, ğ›¾ deviates from ğœ‹ and serves the incumbent (possible, since that queue is non-empty). Between ğ‘›âˆ— + 1 and ğ‘šâˆ—, ğ›¾ follows ğœ‹ albeit with one slot delay, i.e., it does whatever ğœ‹ did one slot ago. Clearly,
ğ‘„ğ›¾ (ğ‘¡) = ğ‘„ ğœ‹ (ğ‘¡), âˆ€ ğ‘¡ âˆˆ [1, ğ‘›âˆ—) âˆª [ğ‘šâˆ— + 1, âˆ), and ğ‘„ğ›¾ (ğ‘¡) â‰¤ ğ‘„ ğœ‹ (ğ‘¡), âˆ€ ğ‘¡ âˆˆ [ğ‘›âˆ— + 1, â‰¤ ğ‘šâˆ—],

34

whenever ğ‘šâˆ— < âˆ. This relation is true for every sample path ğœ”. ğ‘šâˆ— is set equal to âˆ whenever either ğ‘›âˆ— = âˆ, or, ğ›¾ is able to serve a packet in some slot ğ‘™ (â‰¥ ğ‘›âˆ— + 1) while ğœ‹ could not serve any packet in slot
ğ‘™ âˆ’ 1.

To explain the latter case further, observe that after ğ‘›âˆ—, ğ›¾ does whatever ğœ‹ did one slot ago. If ğœ‹ switched

to

some

empty

queue

in

ğ‘™ âˆ’ 1,

ğ›¾

switches

to

the

same

queue

in

ğ‘™.

But

if

ğ‘
ğœ‹ğ‘™âˆ’1

received

a

packet

in

ğ‘™ âˆ’ 1,

ğ›¾

will

be able to serve that packet increasing ğ‘„ ğœ‹ (ğ‘¡) âˆ’ ğ‘„ ğœ‰ (ğ‘¡) to 2 (one at ğ‘›âˆ— and the second at ğ‘™). Since ğ›¾ follows ğœ‹

with exactly one step delay, ğœ‹ will never be able to make up the diï¬€erence! Hence, ğ‘šâˆ— = âˆ.

To complete the proof, one needs to consider epochs ğ‘™âˆ— such as:

ğ‘™âˆ—

:=

inf {ğ‘›

â‰¥

1

:

ğœ‹
ğ‘„ğ‘

(ğ‘›)

>

0,

ğœ‹
ğ‘„ğ‘

(ğ‘›)

>

0,

ğœ‹ğ‘›âˆ’1

ğœ‹ğ‘›

and ğœ‹ğ‘›ğ‘ = 2}, (17)

wherein the queue which ğœ‹ decides to serve, unlike the case with ğ‘›âˆ—, is non-empty and hence, slot ğ‘™âˆ— is not wasted. Even in this case deï¬ning ğ›¾ as before produces a policy that does no worse than ğœ‹ in terms of total system backlog.
In the same manner, ï¬nd such an ğ‘›âˆ— (or ğ‘™âˆ— as the case may be) for ğ›¾ and reï¬ne this policy using the procedure described. Iterating this procedure, one ends up with a policy say ğœ‰, for which such an instant never exists, i.e., which never switches to a diï¬€erent queue when the incumbent is nonempty. This is by deï¬nition exhaustive. We have, thus, deï¬ned both queueing processes on some common probability space (Î©, F , P) and for every ğœ” âˆˆ Î©, we have shown that

ğ‘„ ğœ‰ (ğ‘¡, ğœ”) â‰¤ ğ‘„ ğœ‹ (ğ‘¡, ğœ”), âˆ€ ğ‘¡ â‰¥ 1,

which means that âˆ€ğ‘¥ âˆˆ R,

P{ğœ”

:

ğ‘„ğœ‹ (ğ‘¡,

ğœ”)

>

ğ‘¥}

â‰¥

P{ğœ”

:

ğœ‰
ğ‘„

(ğ‘¡,

ğœ”)

>

ğ‘¥}.

(18)

This coupling argument shows that

ğ‘ ğ‘¡

ğ‘„ ğœ‰ (ğ‘¡) â‰¤ ğ‘„ ğœ‹ (ğ‘¡), âˆ€ ğ‘¡ â‰¥ 1.

(19)

11.3 Proof of Prop. 2

To prove this we invoke Theorem (3.1) in [FL96] that proves the stability of certain exhaustive service policies with state dependent routing. We ï¬rst require some more notation.

We denote by ğ‘†(ğ‘¡) the queue in service during slot ğ‘¡, and set ğ‘†(ğ‘¡) = 0 if the server is idling at some queue

(which from Prop. 1, has to be empty) during some slot. We denote by ğ‘Šğ‘›, the time taken by the server

to

begin

the

ğ‘¡â„
ğ‘›

service.

By this we mean the time taken by the server to ï¬nd a non empty queue after

serving some queue. So, if the incumbent is non empty, ğ‘Šğ‘› = 0 since the server simply begins serving the

next packet in the queue served in the previous slot without switching away from it. Otherwise the server

begins to search for a non empty queue to begin a busy period. Speciï¬cally, if ğ‘„ğ‘†(0) (0) = 0, then ğ‘Š1 is the

time taken to ï¬nd a non empty queue. During this period, the server may have visited several empty queues.

Assume the underlying probability space is denoted by (Î©, F , ğ‘ƒ) and let

Fğ‘› := ğœ [ğ‘„1 (ğ‘¡), Â· Â· Â· , ğ‘„ ğ‘ (ğ‘¡), ğ‘†(ğ‘¡)] , ğ‘¡ â‰¤ ğ‘› , ğ‘› â‰¥ 0,

35

be the ï¬ltration describing the history of the system. Let ğ´ğ‘– [ğ‘¡] be the number of arrivals to queue ğ‘– until and

including time ğ‘¡, and ğ´[ğ‘¡] =

ğ‘ ğ‘–=1

ğ´ğ‘–

[ğ‘¡],

the

total

number

of

arrivals

to

the

system

over

the

same

duration.

The proof of Theorem (3.1) in [FL96] relies on two assumptions7 that we show are satisï¬ed in our case. Firstly, that there exists ğ‘¤ > 0 such that

E [ğ‘Š1|F0] < ğ‘¤, ğ‘ƒ âˆ’ ğ‘.ğ‘ . on ğ‘„ğ‘†(0) = 0 ,

(20)

and secondly that there exists some ğ‘ > 0 such that

ğ‘

âˆ‘ï¸

ğ‘ƒ ( ğ´(ğ‘Š1) = 0|F0) > ğ‘, ğ‘ƒ âˆ’ ğ‘.ğ‘ . on ğ‘„ğ‘†(0) = 0, ğ‘‹ğ‘– (0) > 0 .

(21)

ğ‘–=1

In other words, (20) means that if the system starts out empty, the time taken to ï¬nd a non empty queue under the policy being considered, should have a ï¬nite mean. (21), on the other hand, refers to the fact that when the system starts oï¬€ non empty and the server is at an empty queue at time 0, the probability of 0 arrivals in ğ‘Š1 is positive.
First note that on {ğ‘„ğ‘†(0) = 0}, ğ‘Š1 â‰¥ 1, and let ğœ†ğ‘šğ‘–ğ‘› = min1â‰¤ğ‘–â‰¤ğ‘ ğœ†ğ‘– be the smallest arrival rate which, by assumption is strictly positive. The ï¬rst assumption is satisï¬ed, since

âˆ

âˆ‘ï¸

E [ğ‘Š1|F0] =

ğ‘ƒ{ğ‘Š1 â‰¥ ğ‘˜ |F0}

ğ‘˜ =1

(âˆ—ğ‘)

âˆ
âˆ‘ï¸

â‰¤

(1 âˆ’ ğœ†ğ‘†(ğ‘˜))ğ‘˜

ğ‘˜ =1

âˆ

âˆ‘ï¸

â‰¤

(1 âˆ’ ğœ†ğ‘šğ‘–ğ‘›)ğ‘˜

ğ‘˜ =1

1

=

âˆ’ 1 < âˆ.

ğœ†ğ‘šğ‘–ğ‘›

Inequality (âˆ—ğ‘) is true, since, for the walking time to be at least ğ‘˜, the ğ‘˜ğ‘¡â„ polled queue, i.e., ğ‘†(ğ‘˜), must be empty. Since on {ğ‘„ğ‘†(0) = 0} the system also starts oï¬€ empty, this probability is (1 âˆ’ ğœ†ğ‘†(ğ‘˜) )ğ‘˜ . To prove (21), ï¬rst deï¬ne ğ‘ğ‘˜ = ğ‘ƒ{ğ‘Š1 = ğ‘˜ |F0}.

âˆ

âˆ‘ï¸

ğ‘ƒ{ ğ´(ğ‘Š1)|F0} =

ğ‘ƒ{ ğ´(ğ‘˜) = 0|F0, ğ‘Š1 = ğ‘˜ }ğ‘ƒ{ğ‘Š1 = ğ‘˜ |F0}

ğ‘˜ =1

âˆ

âˆ‘ï¸

=

ğ‘ƒ{ ğ´(ğ‘˜) = 0|F0, ğ‘Š1 = ğ‘˜ } ğ‘ğ‘˜ .

ğ‘˜ =1

âˆğ‘

âˆ‘ï¸ âˆ‘ï¸

=

(1 âˆ’ ğœ†ğ‘–)ğ‘˜ ğ‘ğ‘˜.

ğ‘˜=1 ğ‘–=1

But on {ğ‘‹ğ‘†(0) = 0}, ğ‘1 > (1 âˆ’ ğœ†ğ‘šğ‘–ğ‘›) ğ‘.ğ‘ . So,

ğ‘
âˆ‘ï¸ ğ‘ƒ{ ğ´(ğ‘Š1)|F0} = ğ‘1 (1 âˆ’ ğœ†ğ‘–)
ğ‘–=1
7Eqn. (2.3) and Eqn. (2.4) in [FL96].

36

âˆğ‘

âˆ‘ï¸ âˆ‘ï¸

+

(1 âˆ’ ğœ†ğ‘–)ğ‘˜ ğ‘ğ‘˜

ğ‘˜=2 ğ‘–=1

ğ‘
âˆ‘ï¸ â‰¥ (1 âˆ’ ğœ†ğ‘–) > 0.
ğ‘–=1

With both (20) and (21) satisï¬ed, we note that Theorem (3.1) in [FL96] is proved under a much more general model, where the behavior of the system is inï¬‚uenced by another process ğ‘ˆ (ğ‘¡), ğ‘¡ â‰¥ 0, that takes values in some measurable space (U, U). Setting U = Nğ‘ and ğ‘ˆ (ğ‘¡) = ğ‘‰ (ğ‘¡), the proof is complete.

11.4 LEQ in Symmetric Systems
Under symmetry (Eqn. (7)), ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥1â‰¤ğ‘–â‰¤ğ‘ ğœ†ğ‘–ğ‘‰ğ‘– (ğ‘¡) = ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥1â‰¤ğ‘–â‰¤ğ‘ ğ‘‰ğ‘– (ğ‘¡) and the policy reduces to a cyclic exhaustive service policy, as can be seen from the following example. Consider the scenario with 4 queues in the system and suppose that at the beginning of Queue 1's service, V = [0, ğ‘£2, ğ‘£3, ğ‘£4], with ğ‘£2 > ğ‘£3 > ğ‘£4. At the end of Queue 1's service, the vector changes to V = [0, ğ‘£2, ğ‘£3, ğ‘£4], but the ordering is still preserved, i.e., ğ‘£2 > ğ‘£3 > ğ‘£4 > ğ‘£1 = 0. Hence, Queue 2 is chosen for service next. But at the end of queue 2's service, once again, we see that ğ‘£3 > ğ‘£4 > ğ‘£1 , as it was at the beginning of Queue 2's service, and Queue 3 is chosen, after which queue 4 is chosen followed by queue 1 and this process repeats. We see that under symmetry, LEQ induces a cyclic service system. This policy is discussed in detail in Sec. 4.5. where we will, in fact, show it to be mean delay optimal in symmetric systems. This also helps bolster our conï¬dence in the LEQ policy itself. We now explore in greater detail the behavior of the LEQ policy in symmetric systems.

11.5 Proof of Thm. 3

In this section, we return to the system discussed Sec.2, i.e., one that is not necessarily symmetric8. The analysis proceeds along the lines of the proof of the theorem in [AKL92]. We will be looking at the systemâ€™s state only at the epochs at which the server begins its visit to a queue.

With a slight abuse of notation, we deï¬ne this systemâ€™s state is by s(ğ‘›) = [Q(ğ‘›), ğ¼ (ğ‘›)]ğ‘‡ , where, Q(ğ‘›) =

[ğ‘„1 (ğ‘›),

ğ‘„2(ğ‘›), . . . , ğ‘„ğ‘ (ğ‘›)]ğ‘‡

,ğ‘›

â‰¥

1

is

the

vector

of

queue

lengths

at

the

ğ‘¡â„
ğ‘›

switching

instant

(at

which

the

server visits the ğ‘›ğ‘¡â„ queue), ğ¼ (ğ‘›) is the identity of the ğ‘›ğ‘¡â„ queue polled. Clearly, s(ğ‘›) âˆˆ Nğ‘ Ã— ğ¼, and this

process is embedded at the instants at which the server arrives at a queue.

Further,

the

number

of

arrivals

to

queue

ğ‘˜

in

ğ‘¡

time-slots

is

denoted

by

ğ´ğ‘˜ (ğ‘¡)

and

the

length

of

the

ğ‘¡â„
ğ‘›

busy

period starting with ğ‘™ packets by ğºğ‘› (ğ‘™). Also,

ğ¼ (ğ‘›) + 1 if 1 â‰¤ ğ‘› â‰¤ ğ‘ âˆ’ 1

ğ¼ (ğ‘› + 1) =

1

if ğ‘› = ğ‘.

Consequently, when

1. ğ‘— â‰  ğ¼ (ğ‘›)

ï£±ğ‘„ ï£´

ğ‘—

(ğ‘›)

+

ğ´

ğ‘—

ğºğ‘›

ğ‘„ğ¼ (ğ‘›) (ğ‘›)

,

ï£´

ï£´ï£²

ğ‘„ ğ‘— (ğ‘› + 1) = if ğ‘„ğ¼ (ğ‘›) (ğ‘›) â‰¥ 1

ï£´ ï£´ï£´ğ‘„

ğ‘—

(ğ‘›)

+

ğ´ğ‘—

(1),

if

ğ‘„ğ¼

(ğ‘›)

(ğ‘›)

=

0

ï£³

8Proving stability for this system obviously proves stability in the symmetric system.

37

2. ğ‘— = ğ¼ (ğ‘›)

ğ‘„ ğ‘— (ğ‘› + 1) = ğ´ ğ‘— (1).

The mean duration of a busy period, Eğµ(ğ¼ (ğ‘›)) of queue ğ¼ (ğ‘›) beginning with one packet is found by observing that

Eğµ(ğ¼ (ğ‘›)) = 1 Ã— ğœ†ğ¼ (ğ‘›) + {1 + Eğºğ‘› (ğ‘™)}{1 âˆ’ ğœ†ğ¼ (ğ‘›) } .

â‡’ Eğµ(ğ¼ (ğ‘›)) =

1 .

1 âˆ’ ğœ†ğ¼ (ğ‘›)

Hence, since ğºğ‘› (ğ‘™) begins with ğ‘™ packets instead of one,

Eğºğ‘› (ğ‘™) = ğ‘™ Ã— 1 Ã— ğœ†ğ¼ (ğ‘›) + {1 + Eğºğ‘› (ğ‘™)}{1 âˆ’ ğœ†ğ¼ (ğ‘›) }

ğ‘™ =
1 âˆ’ ğœ†ğ¼ (ğ‘›)

ğœ†ğ‘— â‡’ Eğ´ ğ‘— (ğºğ‘› (ğ‘™)) = 1 âˆ’ ğœ†ğ¼ (ğ‘›) ğ‘™ âˆ€ ğ‘— â‰  ğ¼ (ğ‘›)

âˆ‘ï¸

ğœŒ âˆ’ ğœ†ğ¼ (ğ‘›)

â‡’ E ğ´ ğ‘— (ğºğ‘› (ğ‘™)) = 1 âˆ’ ğœ†ğ¼ (ğ‘›) ğ‘™. (22)

ğ‘—â‰ ğ¼ (ğ‘›)

We will now show that ğœŒ =

ğ‘
ğ‘–=1 ğœ†ğ‘–

< 1 is a suï¬ƒcient condition for stability.

Clearly, {Qğ‘›, ğ‘› â‰¥ 1}, is an

irreducible DTMC. However, it is not time homogeneous since, as (22) shows, the transition probabilities

depend on the queue being served, i.e., on ğ¼ (ğ‘›). Hence, as deï¬ned in [AKL92], the system is said to be stable

if the ğ‘ irreducible, homogeneous DTMCs {[Q(ğ‘›ğ‘ + ğ‘˜), ğ‘˜] , ğ‘› â‰¥ 1, 1 â‰¤ ğ‘˜ â‰¤ ğ‘, ğ‘– âˆˆ {1, 2}} are all ergodic.

Now, from the deï¬nition of ğ‘„ ğ‘— (ğ‘› + 1), we see that

ï£®ğ‘

ï£¹

ğ‘

ï£¯âˆ‘ï¸

ï£º

âˆ‘ï¸

E ï£¯ ğ‘„ ğ‘— (ğ‘› + 1)|Q(ğ‘›)ï£º â‰¤

ğ‘„ ğ‘— (ğ‘›) + ğœŒ

ï£¯

ï£º

ï£¯ ğ‘—=1

ï£º

ğ‘— =1

ï£°

ï£»

ğœŒ âˆ’ ğœ†ğ¼ (ğ‘›) + 1 âˆ’ ğœ†ğ¼ (ğ‘›) ğ‘„ğ¼ (ğ‘›) (ğ‘›) âˆ’ ğ‘„ğ¼ (ğ‘›) (ğ‘›)

ğ‘

âˆ‘ï¸

=

ğ‘„ ğ‘— (ğ‘›) + ğœŒ âˆ’ (1 âˆ’ ğœŒ)â„ğ¼ (ğ‘›) ğ‘„ğ¼ (ğ‘›) (ğ‘›),

ğ‘— =1

1 where â„ğ¼ (ğ‘›) = 1 âˆ’ ğœ†ğ¼ (ğ‘›) ,

which means that

ï£®ğ‘

ï£¹

ï£® ï£®ğ‘

ï£¹

ï£¹

ï£¯âˆ‘ï¸

ï£º

ï£¯ ï£¯âˆ‘ï¸

ï£º

ï£º

E ï£¯ ğ‘„ ğ‘— (ğ‘› + 2)|Q(ğ‘›)ï£º = E ï£¯E ï£¯ ğ‘„ ğ‘— (ğ‘› + 2) | Q(ğ‘› + 1)ï£º | Q(ğ‘›)ï£º

ï£¯

ï£º

ï£¯ï£¯

ï£º

ï£º

ï£¯ ğ‘—=1

ï£º

ï£¯ ï£¯ ğ‘—=1

ï£º

ï£º

ï£°

ï£»

ï£°ï£°

ï£»

ï£»

ğ‘
âˆ‘ï¸ â‰¤ E ğ‘„ ğ‘— (ğ‘› + 1) + ğœŒ

ğ‘— =1

âˆ’(1 âˆ’ ğœŒ)â„ğ¼ (ğ‘›+1) ğ‘„ğ¼ (ğ‘›+1) (ğ‘› + 1) | Q(ğ‘›)

ğ‘
âˆ‘ï¸ â‰¤ E ğ‘„ ğ‘— (ğ‘› + 1) | Q(ğ‘›) + ğœŒ
ğ‘— =1

38

âˆ’(1 âˆ’ ğœŒ)â„ğ¼ (ğ‘›+1) ğ‘„ğ¼ (ğ‘›+1) (ğ‘› + 1)

ğ‘

âˆ‘ï¸

=

ğ‘„ ğ‘— (ğ‘›) + 2ğœŒ âˆ’ (1 âˆ’ ğœŒ) â„ğ¼ (ğ‘›) ğ‘„ğ¼ (ğ‘›) (ğ‘›)

ğ‘— =1

+â„ğ¼ (ğ‘›+1) ğ‘„ğ¼ (ğ‘›+1) (ğ‘›) .

Proceeding similarly, we get

ï£®ğ‘

ï£¹

ğ‘

ï£¯âˆ‘ï¸

ï£º

âˆ‘ï¸

E ï£¯ ğ‘„ ğ‘— (ğ‘› + 2ğ‘) | Q(ğ‘›)ï£º â‰¤

ğ‘„ ğ‘— (ğ‘›) + 2ğ‘ ğœŒ

ï£¯

ï£º

ï£¯ ğ‘—=1

ï£º

ğ‘— =1

ï£°

ï£»

2ğ‘ âˆ’1
âˆ‘ï¸

âˆ’(1 âˆ’ ğœŒ)

â„ğ¼ (ğ‘›+ğ‘š) ğ‘„ğ¼ (ğ‘›+ğ‘š) (ğ‘›),

ğ‘š=0

ï£®ğ‘

ğ‘

ï£¹

ï£¯âˆ‘ï¸

âˆ‘ï¸

ï£º

â‡’ E ï£¯ ğ‘„ ğ‘— (ğ‘› + 2ğ‘) âˆ’ ğ‘„ ğ‘— (ğ‘›) | Q(ğ‘›)ï£º â‰¤ 2ğ‘ ğœŒ

ï£¯

ï£º

ï£¯ ğ‘—=1

ğ‘— =1

ï£º

ï£°

ï£»

2ğ‘ âˆ’1
âˆ‘ï¸

âˆ’(1 âˆ’ ğœŒ)

â„ğ¼ (ğ‘›+ğ‘š) ğ‘„ğ¼ (ğ‘›+ğ‘š) (ğ‘›).

(23)

ğ‘š=0

Clearly, the RHS of (23) is at most 2ğ‘ ğœŒ, and if for even one 1

â‰¤

ğ‘˜

â‰¤

2ğ‘

and ğœ–

>

0, ğ‘„ğ¼ (ğ‘›+ğ‘˜) (ğ‘›)

>

(

1âˆ’ğœŒ)

ğ‘ğœŒ â„(ğ¼

ğœ– (

ğ‘›+

ğ‘˜

)

)

,

then E

ğ‘ ğ‘— =1

ğ‘„

ğ‘—

(ğ‘›

+

2ğ‘)

âˆ’

ğ‘ ğ‘— =1

ğ‘„ ğ‘— (ğ‘›)

|

Q(ğ‘›)

< âˆ’ğœ–. Hence, by the Foster-Lyapunov criterion ( [FMM95],

Thm. 2.2.3), we see that {[Q(ğ‘›ğ‘ + ğ‘˜), ğ‘˜, ğ‘–] , ğ‘› â‰¥ 1} is positive recurrent for every 1 â‰¤ ğ‘˜ â‰¤ ğ‘, and ğ‘– âˆˆ {1, 2}. Being irreducible DTMCs as well, it is also ergodic.

11.6 Formulating the MDP

1. State Space: The state of the system at time ğ‘› â‰¥ 1 is the vector

ğ‘ (ğ‘¡) = ğ‘„ğ‘¢ğ‘›âˆ’1 (ğ‘›), V(ğ‘›), r(ğ‘›), ğ‘¢ğ‘›âˆ’1 . (24) So ğ‘ (ğ‘›) âˆˆ N Ã— Nğ‘ Ã— Nğ‘ âˆ’1 Ã— ğ¼.

2. Action Space: The action space A = ğ¼ for all states.

3. Initial distribution on the State Space: We assume that the system begins empty and so, the initial distribution ğ· is simply I{ğ‘ (0)}, where ğ‘ (0) = [ğ‘, V(0), r(0), ğ‘–0] , is given and hence, known.

4. History: Since the state is observable, the initial history is nothing but the initial state, which is

supplied as the initial information.

â„0 = ğ‘ (0).

(25)

At time ğ‘¡, the history provides the complete picture of successive observations and control actions chosen so far; for ğ‘› â‰¥ 1:

â„ğ‘› = (ğ‘ (0), ğ‘(0), . . . , ğ‘ (ğ‘› âˆ’ 1), ğ‘(ğ‘› âˆ’ 1), ğ‘ (ğ‘›)) ,

(26)

where the action taken at time ğ‘›, ğ‘(ğ‘›) âˆˆ I, âˆ€ğ‘› â‰¥ 0.

39

5. Policies: In general, a policy is a sequence of conditional distributions ğœ‰ = {ğœ‰ğ‘›} such that for each ğ‘›, ğœ‰ğ‘› is a distribution on A given â„ğ‘›. As mentioned before, we restrict attention to policies that serve any queue ğ‘— with ğ‘Ÿ ğ‘— (ğ‘¡) > 0 ï¬rst and then return to serve the incumbent. As a consequence of Prop. 1, we also restrict to the case where if ğ‘ > 0 then we serve ğ‘– again.

6. Transition Law: We denote the current action by ğ‘¢ğ‘› and distinguish two cases: â€¢ ğ‘Ÿğ‘– (ğ‘›) â‰¥ 1 for some ğ‘– âˆˆ ğ¼ âˆ’ ğ‘¢ğ‘›âˆ’1. Then,

ğ‘ğ‘¢ğ‘› (ğ‘ (ğ‘›), ğ‘ (ğ‘› + 1)) = I{ğ‘Ÿ (ğ‘›+1)=ğ‘Ÿ (ğ‘›)âˆ’1} Ã—

ğ‘–

ğ‘–

Î  ğ‘—â‰ ğ‘– I{ğ‘Ÿğ‘— (ğ‘›+1)=ğ‘Ÿğ‘— (ğ‘›) }I{ğ‘¢ğ‘¡ =ğ‘– } Ã—

Î ğ‘˜ğ‘=1Iğ‘¢ğ‘› {ğ‘‰ğ‘˜ (ğ‘›), ğ‘‰ğ‘˜ (ğ‘› + 1)} Ã—

Î ğ‘˜ğ‘=1ğ‘ğ‘¢ğ‘› (ğ‘„ğ‘˜ (ğ‘›), ğ‘„ğ‘˜ (ğ‘› + 1)) ,

(27)

where

ï£±ï£´1 if ğ‘‰ğ‘˜ (ğ‘› + 1) = ğ‘‰ğ‘˜ (ğ‘›) + 1 and ğ‘˜ â‰  ğ‘¢ğ‘›, ï£´ ï£´ï£² ğ¼ğ‘¢ğ‘› {ğ‘‰ğ‘˜ (ğ‘›), ğ‘‰ğ‘˜ (ğ‘› + 1)} := 1 if ğ‘‰ğ‘˜ (ğ‘› + 1) = ğ‘‰ğ‘˜ (ğ‘›) = 0 and ğ‘˜ = ğ‘¢ğ‘›, and
ï£´ ï£´ï£´0 otherwise, ï£³

and

ï£±ï£´ğœ† if ğ‘„ğ‘˜ (ğ‘› + 1) = ğ‘„ğ‘˜ (ğ‘›) + 1

ï£´

ï£´ï£´ï£´ï£´ OR, if ğ‘„ğ‘˜ (ğ‘› + 1) = (ğ‘„ğ‘˜ (ğ‘›) âˆ’ 1)+ + 1

ï£´

ï£´

ï£´ ï£´ ï£´

and ğ‘˜ = ğ‘–,

ï£´

ï£´ï£²

ğ‘ğ‘¢ (ğ‘„ğ‘˜ (ğ‘›), ğ‘„ğ‘˜ (ğ‘› + 1)) := 1 âˆ’ ğœ† if ğ‘„ğ‘˜ (ğ‘› + 1) = ğ‘„ğ‘˜ (ğ‘›) + 0

ğ‘›

ï£´ï£´ï£´ï£´ OR, if ğ‘„ğ‘˜ (ğ‘› + 1) = (ğ‘„ğ‘˜ (ğ‘›) âˆ’ 1)+ + 0

ï£´

ï£´

ï£´ ï£´

and ğ‘˜ = ğ‘–,

ï£´

ï£´

ï£´ï£´ï£´0 otherwise,

ï£³

â€¢ r(ğ‘›) = 0. Then,

ğ‘ğ‘¢ğ‘› (ğ‘ (ğ‘›), ğ‘ (ğ‘› + 1)) = Î  ğ‘— âˆˆğ¼ I{ğ‘Ÿğ‘— (ğ‘›+1)=0} Ã— Î ğ‘˜ğ‘=1Iğ‘¢ğ‘› {ğ‘‰ğ‘˜ (ğ‘›), ğ‘‰ğ‘˜ (ğ‘› + 1)} Ã— Î ğ‘˜ğ‘=1ğ‘ğ‘¢ğ‘› (ğ‘„ğ‘˜ (ğ‘›), ğ‘„ğ‘˜ (ğ‘› + 1)) , (28)

where and

ï£±ï£´1 if ğ‘‰ğ‘˜ (ğ‘› + 1) = ğ‘‰ğ‘˜ (ğ‘›) + 1 and ğ‘˜ â‰  ğ‘¢ğ‘›, ï£´ ï£´ï£² ğ¼ğ‘¢ğ‘› {ğ‘‰ğ‘˜ (ğ‘›), ğ‘‰ğ‘˜ (ğ‘› + 1)} := 1 if ğ‘‰ğ‘˜ (ğ‘› + 1) = ğ‘‰ğ‘˜ (ğ‘›) = 0 and ğ‘˜ = ğ‘¢ğ‘›, and
ï£´ ï£´ï£´0 otherwise, ï£³

ï£±ï£´ğœ† if ğ‘„ğ‘˜ (ğ‘› + 1) = ğ‘„ğ‘˜ (ğ‘›) + 1 and ğ‘˜ â‰  ğ‘¢ğ‘›,

ï£´

ï£´ï£´ï£´ï£´ OR, if ğ‘„ğ‘˜ (ğ‘› + 1) = (ğ‘„ğ‘˜ (ğ‘›) âˆ’ 1)+ + 1

ï£´

ï£´

ï£´ ï£´ ï£´

and ğ‘˜ = ğ‘¢ğ‘›,

ï£´

ï£´ï£²

ğ‘ğ‘¢ (ğ‘„ğ‘˜ (ğ‘›), ğ‘„ğ‘˜ (ğ‘› + 1)) := 1 âˆ’ ğœ† if ğ‘„ğ‘˜ (ğ‘› + 1) = ğ‘„ğ‘˜ (ğ‘›) + 0 and ğ‘˜ â‰  ğ‘¢ğ‘›,

ğ‘›

ï£´ï£´ï£´ï£´ OR, if ğ‘„ğ‘˜ (ğ‘› + 1) = (ğ‘„ğ‘˜ (ğ‘›) âˆ’ 1)+ + 0

ï£´

ï£´

ï£´ ï£´

and ğ‘˜ = ğ‘¢ğ‘›,

ï£´

ï£´

ï£´ï£´ï£´0 otherwise,

ï£³

40

7. Single Stage Cost: This gives the expected cost over the current step when the current state and action are known.

ğ‘
âˆ‘ï¸ ğ‘(ğ‘ (ğ‘›), ğ‘¢ğ‘›) = E ğ‘„ğ‘– (ğ‘›)|ğ‘ ğ‘›

ğ‘–=1

âˆ‘ï¸

âˆ‘ï¸

= ğ‘„ğ‘¢ğ‘›âˆ’1 (ğ‘›) + ğœ† ğ‘‰ğ‘— (ğ‘›) + ğ‘…ğ‘– (ğ‘›), (29)

ğ‘— â‰ ğ‘¢ğ‘›âˆ’1

ğ‘–âˆˆğ¼

which is the expected sum of the current queue lengths conditioned on the current state.

Recall that the optimal cost (Eqn. (11)) is given by

âˆ

ğ‘

ğ½âˆ— (ğ‘ (0)) = ğ‘šğ‘–ğ‘› ğœ‰ Eğ‘ ğœ‰(0) âˆ‘ï¸ ğ›¼ğ‘›E âˆ‘ï¸ ğ‘„ğ‘– (ğ‘›)|ğ‘ ğ‘› . (30)

ğ‘›=0

ğ‘–=1

It is to be noted that ğ½âˆ— (ğ‘ (0)) on the R.H.S of (11) exists for every initial state ğ‘ (0). Since arrivals are IID

Bernoulli variables, the single stage cost can increase at most linearly with time, while the discount factor

ğ›¼ğ‘› decreases exponentially and dominates.

The Bellman Optimality equations [Ber95] associated with this MDP formulation are as follows (recall from Eqn. (12) that we denote ğ½âˆ— (ğ‘; V; r; ğ‘–) by ğ½âˆ— (ğ‘; V; r)). When r = 0,
ğ‘–
ğ½ğ‘–âˆ— (ğ‘ > 0; V; r = 0) = ğ‘ + ğœ† âˆ‘ï¸ ğ‘‰ğ‘˜ + ğ›¼Eğ½ğ‘–âˆ— (ğ‘ âˆ’ 1 + ğ´;
ğ‘˜ â‰ ğ‘–
ğ‘‰ğ‘– = 0, Vâˆ’ğ‘– + 1; r = 0) , ğ½ğ‘–âˆ— (ğ‘ = 0; V; r = 0) = ğœ† âˆ‘ï¸ ğ‘‰ğ‘˜ + ğ›¼ min Eğ½âˆ—ğ‘— ğµ(ğ‘‰ğ‘— );
ğ‘— â‰ ğ‘– ğ‘˜ â‰ ğ‘–
ğ‘‰ğ‘— = 0, Vâˆ’ ğ‘— + 1; r = 0 ,
where ğ´ is a generic Bernoulli(ğœ†) random variable, Vâˆ’ğ‘– = [ğ‘‰1, . . . , ğ‘‰ğ‘–âˆ’1, ğ‘‰ğ‘–+1, . . . , ğ‘‰ğ‘ ] and 1 âˆˆ R(ğ‘ âˆ’1) is the vector with 1â€™s at all coordinates. Finally, if random variable ğ¶ is distributed Binomial(ğ‘‰ğ‘— , ğœ†), ğµ(ğ‘‰ğ‘— ) is a random variable whose distribution is the same as that of (ğ¶ âˆ’ 1)+ + ğ´.

If ğ‘Ÿ ğ‘— â‰¥ 1 for some ğ‘— âˆˆ ğ¼ âˆ’ {ğ‘–}, the server ï¬rst serves the ğ‘—â‰ ğ‘– ğ‘Ÿ ğ‘— packets and then returns to queue ğ‘–. Let ğ‘…Ëœ = ğ‘—â‰ ğ‘– ğ‘Ÿ ğ‘— , ğ¿âˆ’ğ‘– = ğ‘—â‰ ğ‘– ğ‘‰ğ‘— , and ğ¿Ëœâˆ’ğ‘– = ğ‘…ğ‘˜Ëœ=1 ğ›¼(ğ‘…Ëœâˆ’ğ‘˜) (ğ¿âˆ’ğ‘– + ğ‘ ğ‘˜). Clubbing all these ğ‘…Ëœ slots, we get:
ğ‘…Ëœâˆ’1
ğ½ğ‘–âˆ— (ğ‘ > 0; V; r) = ğ‘ âˆ‘ï¸ ğ›¼ğ‘˜ + ğœ†ğ¿Ëœâˆ’ğ‘– + ğ›¼ğ‘…ËœEğ½ğ‘–âˆ— ğ‘ âˆ’ 1 + ğ´Ëœ;
ğ‘˜ =0
ğ‘‰ğ‘– = 0, Vâˆ’ğ‘– + ğ‘…Ëœ1; r = 0

ğ½ğ‘–âˆ— (ğ‘ = 0; V; r) = ğœ†ğ¿Ëœâˆ’ğ‘– + ğ›¼ğ‘…ËœEğ½âˆ—ğ‘— ğ´Ëœ; ğ‘‰ğ‘— = 0,

Vâˆ’ ğ‘— + ğ‘…Ëœ1; r = 0 ,

(31)

where ğ´Ëœ is a Binomial ğ‘…Ëœ, ğœ† random variable and represents the number of arrivals over ğ‘…Ëœ slots.

11.7 Proof of Thm. 4
Before we prove that cyclic exhaustive service solves the discounted cost MDP described in Sec. 11.6, we require an intermediate result on monotonicity of the optimal cost function.
41

11.7.1 Monotonicity of ğ½âˆ— (Â·)

Consider, once again, the Bellman equations.

ğ½ğ‘–âˆ— (ğ‘ > 0; v; r = 0) = ğ‘ + ğœ† âˆ‘ï¸ ğ‘£ğ‘˜ + ğ›¼Eğ½ğ‘–âˆ— (ğ‘ âˆ’ 1 + ğ´;

ğ‘˜ â‰ ğ‘–

ğ‘£ğ‘– = 0, vâˆ’ğ‘– + 1; r = 0) , ğ½ğ‘–âˆ— (ğ‘ = 0; v; r = 0) = ğœ† âˆ‘ï¸ ğ‘£ğ‘˜ + ğ›¼ min Eğ½âˆ—ğ‘— ğµ(ğ‘£ ğ‘— );
ğ‘— â‰ ğ‘– ğ‘˜ â‰ ğ‘–

ğ‘£ ğ‘— = 0, vâˆ’ ğ‘— + 1; r = 0 ,

(32)

where, we recall that if random variable ğ¶ is distributed Binomial(ğ‘£ ğ‘— , ğœ†), ğµ(ğ‘£ ğ‘— ) is a random variable whose distribution is the same as that of (ğ¶ âˆ’ 1)+ + ğ´ and ğ´ is a Bernoulli random variable with Eğ´ = ğœ†. We shall now prove that the optimal cost function is monotonically increasing in the ï¬rst coordinate when r = 0 (this is really the only scenario where decisions might have to be taken).
Lemma 7. When r = 0, the optimal ğ›¼âˆ’discounted cost function, ğ½âˆ— satisï¬es

ğ½âˆ— (ğ‘1, v, 0)

â‰¥

ğ½âˆ— (ğ‘2, v, 0),

âˆ€ğ‘1

â‰¥

ğ‘2,

and

v

âˆˆ

ğ‘
N

.

(33)

Proof. Let M denote the set of all functions ğ‘” : S â†¦â†’ R+. Considering the R.H.S of equations(32), we deï¬ne the Dynamic Programming Operator ğ‘‡ : M â†¦â†’ M as in [Ber95] as follows. For any ğ‘” âˆˆ M,
âˆ‘ï¸ (ğ‘‡ ğ‘”)ğ‘– (ğ‘ > 0, v, r) = ğ‘ + ğœ† ğ‘£ğ‘˜ + ğ›¼Eğ‘”ğ‘– (ğ‘ âˆ’ 1 + ğ´;
ğ‘˜ â‰ ğ‘–
ğ‘£ğ‘– = 0, vâˆ’ğ‘– + 1; r = 0) , âˆ‘ï¸
(ğ‘‡ ğ‘”)ğ‘– (ğ‘ = 0, v, r) = ğœ† ğ‘£ğ‘˜ + ğ›¼ min Eğ‘” ğ‘— ğµ(ğ‘£ ğ‘— );
ğ‘— â‰ ğ‘– ğ‘˜ â‰ ğ‘–
ğ‘£ ğ‘— = 0, vâˆ’ ğ‘— + 1; r = 0 ,
Consider any ğ‘” âˆˆ M that is increasing in ğ‘, i.e., ğ‘”(ğ‘ + ğ‘˜, v, r) â‰¥ ğ‘”(ğ‘, v, r), âˆ€ğ‘˜ â‰¥ 1. When

â€¢ ğ‘ â‰¥ 1:

âˆ‘ï¸ (ğ‘‡ ğ‘”)ğ‘– (ğ‘ + ğ‘˜, v, r) = (ğ‘ + ğ‘˜) + ğœ† ğ‘£ğ‘˜ + ğ›¼Eğ‘”ğ‘– ğ‘ + ğ‘˜ âˆ’ 1 + ğ´;
ğ‘˜ â‰ ğ‘–
ğ‘£ğ‘– = 0, vâˆ’ğ‘– + 1; r = 0 ,

âˆ‘ï¸ â‰¥ ğ‘ + ğœ† ğ‘£ğ‘˜ + ğ›¼Eğ‘”ğ‘– ğ‘ âˆ’ 1 + ğ´;
ğ‘˜ â‰ ğ‘–
ğ‘£ğ‘– = 0, vâˆ’ğ‘– + 1; r = 0 ,
= (ğ‘‡ ğ‘”)ğ‘– (ğ‘, v, r).

This shows that the operator ğ‘‡ preserves monotonicity for ğ‘ â‰¥ 1. Proposition 2.1 of [Ber95] shows
that value iteration, starting from any ğ‘” âˆˆ M, converges to the ï¬xed point of the operator ğ‘‡, namely ğ½âˆ—, which also resides in M. Hence, we see that ğ½âˆ— is monotonically increasing in ğ‘ when ğ‘ â‰¥ 1.

42

â€¢ ğ‘ = 0:

ğ½âˆ— (0; v; r = 0)

=

âˆ‘ï¸ ğœ†ğ‘£

+ ğ›¼ min Eğ½âˆ— ğµ(ğ‘£ ğ‘— ); ğ‘£ ğ‘— = 0, vâˆ’ ğ‘— + 1; r = 0 ,

ğ‘–

ğ‘˜

ğ‘—â‰ ğ‘– ğ‘—

ğ‘˜ â‰ ğ‘–

â€ 
=

âˆ‘ï¸ ğœ†ğ‘£

+ ğ›¼ min Eğ½âˆ— ğµ(ğ‘£ ); ğ‘£

= 0, vâˆ’

+ 1; r = 0 ,

ğ‘˜

ğ‘—âˆˆğ¼ ğ‘—

ğ‘—ğ‘—

ğ‘—

ğ‘˜ â‰ ğ‘–

âˆ‘ï¸ = ğœ† ğ‘£ğ‘˜

ğ‘˜ â‰ ğ‘–

+ğ›¼ min min Eğ½âˆ— ğµ(ğ‘£ ğ‘— ); ğ‘£ ğ‘— = 0, vâˆ’ ğ‘— + 1; r = 0 ,
ğ‘—â‰ ğ‘– ğ‘—

âˆ—
Eğ½

ğ´; ğ‘£ğ‘– = 0, vâˆ’ğ‘– + 1; r = 0

,

ğ‘–

â‰¤ 1 + ğœ† âˆ‘ï¸ ğ‘£ğ‘˜ + ğ›¼Eğ½ğ‘–âˆ— ğ´; ğ‘£ğ‘– = 0, vâˆ’ğ‘– + 1; r = 0 ,
ğ‘˜ â‰ ğ‘–
= ğ½âˆ— (1; v; r = 0).
ğ‘–
In equality â€  minimization over ğ¼ \ {ğ‘–} is the same as minimization over all ğ¼, since attempting to schedule queue ğ‘– would result in slot wastage and idling, which, as Prop. 1 shows is suboptimal and hence, will not result in a smaller cost.

11.7.2 Proof of Thm. 4
In this section, we use râˆ’ğ‘› instead of r to explicitly show which queuesâ€™ ğ‘Ÿ ğ‘— â€™s are known to the server. So, râˆ’ğ‘› includes ğ‘Ÿ ğ‘— âˆ€ ğ‘— â‰  ğ‘›. Let D be a ğµğ‘–ğ‘›(ğ‘£ğ‘› âˆ’ ğ‘£ğ‘š âˆ’ 1, ğœ†) random variable. Wherever it becomes necessary to clarify the measure with respect to (w.r.t) which the expectation is being computed, we shall use Eğœ‡ to explicitly denote expectation w.r.t the probability mass function (p.m.f) ğœ‡. Let ğœˆğ‘š denote the p.m.f of ğµ(ğ‘£ğ‘š), ğœˆğ‘› that of ğµ(ğ‘£ğ‘š) and ğœ‡ that of ğ·, i.e., ğµğ‘–ğ‘›(ğ‘£ğ‘› âˆ’ ğ‘£ğ‘š âˆ’ 1, ğœ†). Also, deï¬ne ğœ’ =Î” ğœˆğ‘š âˆ— ğœ‡ (here, âˆ— denotes convolution) and ğ›½ =Î” ğœˆğ‘š Ã— ğœ‡ (the product measure). Now, with ğ‘£ğ‘› âˆ’ ğ‘£ğ‘š > 0, we can write:
Eğœˆğ‘› ğ½ğ‘›âˆ— ğµ(ğ‘£ğ‘›); ğ‘£ğ‘› = 0, vâˆ’ğ‘› + 1; râˆ’ğ‘› = 0
âˆ’ Eğœˆğ‘š ğ½ğ‘šâˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘š + 1; râˆ’ğ‘š = 0
â‰¤ğ‘ Eğœ’ ğ½ğ‘›âˆ— ğµ(ğ‘£ğ‘š) + ğ·; vâˆ’ğ‘› + 1; râˆ’ğ‘› = 0
âˆ’ Eğœˆğ‘š ğ½ğ‘šâˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘š + 1; râˆ’ğ‘š = 0 (34)
= Eğ›½ ğ½ğ‘›âˆ— ğµ(ğ‘£ğ‘š) + ğ·; vâˆ’ğ‘› + 1; râˆ’ğ‘› = 0
âˆ’ ğ½ğ‘šâˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘š + 1; râˆ’ğ‘š = 0 (35)
ğ‘£ğ‘› âˆ’ ğ‘£ğ‘š âˆ’1
=â€  âˆ‘ï¸ ğ‘ƒ(ğ‘Ÿ) E ğ½ğ‘›âˆ— ğµ(ğ‘£ğ‘š) + ğ‘Ÿ; vâˆ’ğ‘› + 1; râˆ’ğ‘› = 0
ğ‘Ÿ =1
âˆ’ ğ½ğ‘šâˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘š + 1; râˆ’ğ‘š = 0 ğ· = ğ‘Ÿ
43

+ ğ‘ƒ(0) E ğ½ğ‘›âˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘› + 1; râˆ’ğ‘› = 0

âˆ’ ğ½ğ‘šâˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘š + 1; râˆ’ğ‘š = 0 ğ· = 0
ğ‘£ğ‘› âˆ’ ğ‘£ğ‘š âˆ’1
â‰¤ğ‘ âˆ‘ï¸ ğ‘ƒ(ğ‘Ÿ) E ğ½ğ‘›âˆ— ğµ(ğ‘£ğ‘š) + ğ‘Ÿ; vâˆ’ğ‘› + 1; râˆ’ğ‘› = 0
ğ‘Ÿ =1
âˆ’ ğ½ğ‘šâˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘š + 1; râˆ’ğ‘š = 0 ğ· = ğ‘Ÿ (36)

Before we explain inequality ğ‘ we will require the following result.

Lemma 8.

ğ‘ ğ‘¡

ğµ(ğ‘£ğ‘›) â‰¤ ğµ(ğ‘£ğ‘š) âˆ— ğ·,

(37)

where, as before, ğ‘ ğ‘¡ refers to stochastic ordering and âˆ— denotes convolution.

Proof. Refer Sec. 11.8.

Since nondecreasing functions of stochastically ordered random variables are themselves stochastically ordered, inequality ğ‘ follows from Lem. 8 and the monotonicity of ğ½âˆ— in the ï¬rst coordinate as proved in
Lemma.7 in Sec. 11.7.1. In equality â€ , ğ‘ƒ(ğ‘Ÿ) = ğ‘ƒğ‘Ÿ {ğ· = ğ‘Ÿ }, as mentioned before.

To explain inequality ğ‘ we use the following observation about the diï¬€erence between the state in which our controlled Markov chain (CMC) actually is and what the decision maker knows about that state. Note that the lemma that follows is true for CMCs in general. Let X (a countable set) be the state space on which the CMC actually evolves. The MDP is then deï¬ned on the set of all probability mass functions, or p.m.fs on X denoted by P (X) := {p : âˆ€ğ‘¥ âˆˆ X, 0 â‰¤ ğ‘(ğ‘¥) â‰¤ 1, and ğ‘¥âˆˆX ğ‘(ğ‘¥) = 1}. Let the action space be denoted by A.

Lemma 9. Let ğœ‡ âˆˆ P (X) be a probability mass function, or p.m.f, on X (this p.m.f can be degenerate, i.e., 1 at some ğ‘¥ âˆˆ X and 0 elsewhere) and ğœ‹âˆ— any stationary optimal policy (assuming one exists). Denote the
action space when the state is ğœ‡ by ğ´ğœ‡ âŠ‚ A and the state of the CMC at time 0 by ğ‘‹0 âˆˆ X. Finally, let ğ‘ : P (X) Ã— A â†¦â†’ R+ denote the single stage cost and ğœ‡ğ‘œ = ğœ‡. Then9,

âˆ

âˆ

âˆ— âˆ‘ï¸

âˆ— âˆ‘ï¸

ğœ‹

ğ›¼ğ‘˜ ğ‘(ğœ‡ğ‘˜ , ğ´ğ‘˜ ) ğ‘‹0 = ğ‘¥

â‰¥

ğœ‹
E

ğ‘˜
ğ›¼

ğ‘

(

ğœ‡ğ‘˜

,

ğ´ğ‘˜

)

,

Eğœ‡ ğ›¿ğ‘¥

ğ‘˜ =0

ğ‘˜ =0

(38)

where ğœ‡ğ‘˜ âˆˆ P (X), ğ´ğ‘˜ âˆˆ ğ´ğœ‡ , for all ğ‘˜ â‰¥ 0. ğ‘˜

Proof. Intuitively speaking, the L.H.S of (38) is an expectation over the subset of sample paths over which ğ‘‹0 = ğ‘¥ and when decision-making entity (in our case, the centralized scheduler) begins with knowledge of some p.m.f ğœ‡ over the state. Clearly, this does not mean that the entity knows that ğ‘‹0 = ğ‘¥. But the expectation on the R.H.S indicates that the scheduler begins knowing that ğ‘‹0 = ğ‘¥, hence the ğ›¿ğ‘¥ in the subscript. Obviously, the action taken by the decision-making entity when it has complete knowledge of the state (represented by ğ›¿ğ‘¥) cannot be worse than that taken when there is ambiguity about the state (represented by some p.m.f ğœ‡ which might not be ğ›¿ğ‘¥). For details, refer Sec. 11.9 in the Appendix.

In short, the lemma says that while transitioning from conditioning to knowledge, the optimal cost cannot increase. Getting back to proving Eqn. (36), Lem. 9 immediately gives us inequality ğ‘ below, because ğ· = 0
9The discount factor is denoted by ğ›¼.

44

essentially means that queue ğ‘›â€™s distribution is ğµğ‘–ğ‘›(ğ‘£ğ‘š, ğœ†). Inequality ğ‘ is explained in more detail after (39).
E ğ½ğ‘šâˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘š + 1; râˆ’ğ‘š = 0 ğ· = 0
â‰¥ğ‘ E ğ½ğ‘šâˆ— ğµ(ğ‘£ğ‘š); vâˆ’{ğ‘š,ğ‘›} + 1, ğ‘£ğ‘› = ğ‘£ğ‘š + 1; râˆ’ğ‘š = 0

=ğ‘‘ E ğ½ğ‘›âˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘› + 1; râˆ’ğ‘› = 0

=ğ‘’ E ğ½ğ‘›âˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘› + 1; râˆ’ğ‘› = 0 ğ· = 0 . (39)

When the scheduler knows that both queue ğ‘š and queue ğ‘› have the same number of packets, viz, ğµ(ğ‘£ğ‘š), serving either queue gives the same expected cost, since both queues have statistically similar arrival processes. So, equality ğ‘‘ follows from the fact that two queues of length Bin(ğ‘£ğ‘š, ğœ†), with equal arrival rates are stochastically indistinguishable. The R.H.S of equality ğ‘’ is the expected cost of serving queue ğ‘›, when the server knows that queue ğ‘š is distributed ğµğ‘–ğ‘›(ğ‘£ğ‘š, ğœ†) and the backlog of queue ğ‘š is actually a ğµğ‘–ğ‘›(ğ‘£ğ‘š, ğœ†) random variable, but that is exactly the R.H.S of equality ğ‘‘! Contrast this with the L.H.S of inequality ğ‘, where the server only knows that queue ğ‘› is distributed ğµğ‘–ğ‘›(ğ‘£ğ‘›, ğœ†), while conditioning on ğ· = 0 means that queue ğ‘› is actually distributed ğµğ‘–ğ‘›(ğ‘£ğ‘š, ğœ†). So,
E ğ½ğ‘›âˆ— ğµ(ğ‘£ğ‘š) + ğ‘Ÿ; vâˆ’ğ‘› + 1; râˆ’ğ‘› = 0

âˆ’ ğ½ğ‘šâˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘š + 1; râˆ’ğ‘š = 0 ğ· = 0 â‰¤ 0. (40)

Now, on to the R.H.S of inequality ğ‘. Invoking Lem. 9 and noting that ğ‘Ÿğ‘› = ğ‘Ÿ means the scheduler knows that queue ğ‘› has at least ğ‘Ÿ packets, we get
E ğ½ğ‘šâˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘š + 1; râˆ’ğ‘š = 0 ğ· = ğ‘Ÿ

â‰¥

E

ğ½âˆ—
ğ‘š

ğµ(ğ‘£ğ‘š); vâˆ’ğ‘š + 1; r{âˆ’ğ‘š,ğ‘›} = 0, ğ‘Ÿğ‘› = ğ‘Ÿ

=ğ‘“ E ğ½ğ‘›âˆ— ğµ(ğ‘£ğ‘š) + ğ‘Ÿ; vâˆ’ğ‘› + 1; râˆ’ğ‘› = 0

=ğ‘” E ğ½ğ‘›âˆ— ğµ(ğ‘£ğ‘š) + ğ‘Ÿ; vâˆ’ğ‘š + 1; rğ‘› = 0 ğ· = ğ‘Ÿ . (41)

Equality ğ‘“ is explained as follows. In the space of policies we are considering, a server always ï¬rst serves all queues with positive ğ‘Ÿ and then returns to the incumbent. So, when it is known that ğ‘Ÿğ‘› = ğ‘Ÿ, the server will ï¬rst serve the ğ‘Ÿ packets in queue ğ‘› and then return to queue ğ‘š. But that will result in the same mean cost as serving queue ğ‘› exhaustively, when it is known that queue ğ‘›â€™s backlog is distributed ğ›¿ğ‘Ÿ âˆ— ğµğ‘–ğ‘›(ğ‘£ğ‘š, ğœ†). Equality ğ‘” uses the same logic as Equality ğ‘’ in (39).
E ğ½ğ‘›âˆ— ğµ(ğ‘£ğ‘š) + ğ‘Ÿ; vâˆ’ğ‘› + 1; râˆ’ğ‘› = 0 âˆ’ ğ½ğ‘šâˆ— ğµ(ğ‘£ğ‘š); vâˆ’ğ‘š + 1; râˆ’ğ‘š = 0 ğ· = ğ‘Ÿ â‰¤ 0, âˆ€1 â‰¤ ğ‘Ÿ â‰¤ ğ‘£ğ‘› âˆ’ ğ‘£ğ‘š. (42)

From (40) and (42), the policy structure now follows.

11.8 Proof of Lem. 8
Given ğ‘˜ â‰¥ 1 if ğ‘ is a random variable with p.m.f Bin(ğ‘˜, ğœ†) we deï¬ne ğµËœ(ğ‘˜) as the p.m.f of (ğ‘ âˆ’ 1)+. Let ğ‘‹ğ‘˜ (ğ‘˜ â‰¥ 1), and ğ‘Œğ‘› (ğ‘› â‰¥ 1) be random variables with distributions ğµËœ(ğ‘˜), and Bin(ğ‘›, ğœ†), respectively. In what
45

follows, we will ï¬rst show that

ğ‘ ğ‘¡

ğ‘‹ğ‘˜ + ğ‘Œğ‘› â‰¥ ğ‘‹ğ‘˜+1 + ğ‘Œğ‘›âˆ’1, âˆ€ğ‘˜ â‰¥ 1.

(43)

Since

the

L.H.S

of

Eqn.

43,

ğ‘‹ğ‘˜

+ ğ‘Œğ‘›

ğ‘‘
=

ğ‘‹ğ‘˜

+ ğ‘Œ1

+ ğ‘Œğ‘›âˆ’1

(where

ğ‘‘
=

denotes

equality

of

distribution),

it

is

suï¬ƒcient

to prove that

ğ‘ ğ‘¡
ğ‘‹ğ‘˜ + ğ‘Œ1 â‰¥ ğ‘‹ğ‘˜+1.

(44)

We show this by proving that

ğ‘ƒ{ğ‘‹ğ‘˜ + ğ‘Œ1 â‰¤ ğ‘™} â‰¤ ğ‘ƒ{ğ‘‹ğ‘˜+1 â‰¤ ğ‘™ âˆ’ 1}, âˆ€ğ‘™ âˆˆ {0, 1, . . . , ğ‘˜ }.

(45)

We consider several cases

â€¢ ğ‘™=0 while

ğ‘ƒ{ğ‘‹ğ‘˜+1 â‰¤ 0} = (1 âˆ’ ğœ†)ğ‘˜+1 + (ğ‘˜ + 1) (1 âˆ’ ğœ†)ğ‘˜ğœ† = (1 âˆ’ ğœ†)ğ‘˜ (1 + ğ‘˜ğœ†) ,
ğ‘ƒ{ğ‘‹ğ‘˜ + ğ‘Œ1 â‰¤ 0} = (1 âˆ’ ğœ†)ğ‘˜ + ğ‘˜ (1 âˆ’ ğœ†)ğ‘˜âˆ’1ğœ† (1 âˆ’ ğœ†) = (1 âˆ’ ğœ†)ğ‘˜ (1 + (ğ‘˜ âˆ’ 1)ğœ†) < ğ‘ƒ{ğ‘‹ğ‘˜+1 â‰¤ 0}.

â€¢ 1â‰¤ğ‘™ â‰¤ ğ‘˜âˆ’1

ğ‘ƒ{ğ‘‹ğ‘˜+1 = ğ‘™} = ğ‘˜ğ‘™ ++ 11 ğœ†ğ‘™+1 (1 âˆ’ ğœ†)ğ‘˜âˆ’ğ‘™,

while

ğ‘ƒ{ğ‘‹ğ‘˜ + ğ‘Œ1 = ğ‘™} =

ğ‘˜ ğœ†(ğ‘™+1) (1 âˆ’ ğœ†) (ğ‘˜âˆ’ğ‘™âˆ’1) (1 âˆ’ ğœ†) ğ‘™+1

+

ğ‘˜

ğ‘™
ğœ†

(1

âˆ’

ğœ†)

(

ğ‘˜

âˆ’ğ‘™)

ğœ†

ğ‘™

=

ğ‘˜

ğ‘˜ +

ğœ†ğ‘™+1 (1 âˆ’ ğœ†) (ğ‘˜âˆ’ğ‘™)

ğ‘™+1 ğ‘™

= ğ‘ƒ{ğ‘‹ğ‘˜+1 = ğ‘™}.

Hence, in this case, ğ‘ƒ{ğ‘‹ğ‘˜+1 â‰¤ ğ‘™} â‰¥ ğ‘ƒ{ğ‘‹ğ‘˜ + ğ‘Œ1 â‰¤ ğ‘™}.
â€¢ ğ‘™=ğ‘˜
ğ‘ƒ{ğ‘‹ğ‘˜+1 = ğ‘™} = ğœ†ğ‘˜+1, and ğ‘ƒ{ğ‘‹ğ‘˜ + ğ‘Œ1 = ğ‘™} = ğ‘ƒ{ğ‘‹ğ‘˜ = ğ‘˜ }ğ‘ƒ{ğ‘Œ1 = 1}
= ğœ†ğ‘˜+1 = ğ‘ƒ{ğ‘‹ğ‘˜+1 = ğ‘™}.
(46)

Once again, ğ‘ƒ{ğ‘‹ğ‘˜+1 â‰¤ ğ‘˜ } â‰¥ ğ‘ƒ{ğ‘‹ğ‘˜ + ğ‘Œ1 â‰¤ ğ‘˜ }.

46

ğ‘ ğ‘¡

ğ‘ ğ‘¡

This proves Eqn. 44 and hence, Eqn. 43. By the same token, it is at once obvious that ğ‘‹ğ‘˜ +ğ‘Œğ‘› â‰¥ ğ‘‹ğ‘˜+1 +ğ‘Œğ‘›âˆ’1 â‰¥

ğ‘ ğ‘¡

ğ‘‹ğ‘˜+2 + ğ‘Œğ‘›âˆ’2 . . . â‰¥ ğ‘‹ğ‘˜+ğ‘›, which means that,

ğµËœ(ğ‘˜ + ğ‘›)

ğ‘ ğ‘¡
â‰¤

ğµËœ(ğ‘˜) âˆ— ğµğ‘–ğ‘›(ğ‘›)

â‡’ ğµËœ(ğ‘˜ + ğ‘›) âˆ— ğµğ‘–ğ‘›(1, ğœ†)

ğ‘ ğ‘¡
â‰¤

ğµËœ(ğ‘˜) âˆ— ğµğ‘–ğ‘›(ğ‘›) âˆ— ğµğ‘–ğ‘›(1, ğœ†)

ğ‘ ğ‘¡

â‡’ ğµ(ğ‘˜ + ğ‘›) â‰¤ ğµ(ğ‘˜) âˆ— B(ğ‘›).

(47)

Lem. 8 follows by setting ğ‘£ğ‘š = ğ‘˜ and ğ‘£ğ‘› = ğ‘˜ + ğ‘›, in (47).

11.9 Proof of Lem. 9

For every ğ‘ âˆˆ A denote by ğ‘ğ‘ (ğ‘§, ğœˆ) the stochastic transition kernel10 from P (X) Ã— A â†¦â†’ P (X). Such a kernel exists by Lem. 3.2 and Eqn. 3.7 in Chapter 4 of [HL89]. Now, observe that the R.H.S of 38

âˆ

âˆ— âˆ‘ï¸

ğœ‹

ğ‘˜
ğ›¼

ğ‘

(

ğœ‡ğ‘˜

,

ğ´ğ‘˜

)

Eğ›¿ğ‘¥

ğ‘˜ =0

= ğ‘(ğ›¿ğ‘¥, ğœ‹âˆ—(ğ›¿ğ‘¥))

âˆ«
+ğ›¼
P ( X)

âˆ
Eğœˆğœ‹âˆ— âˆ‘ï¸ ğ›¼ğ‘˜âˆ’1ğ‘(ğœ‡ğ‘˜ , ğ´ğ‘˜ )
ğ‘˜ =1

Ã—ğ‘ ğœ‹âˆ—( ğ›¿ğ‘¥) (ğ›¿ğ‘¥, ğ‘‘ğœˆ)

#1
â‰¤ ğ‘(ğ›¿ğ‘¥, ğ‘)

âˆ« +ğ›¼

âˆ
Eğœˆğœ‹âˆ— âˆ‘ï¸ ğ›¼ğ‘˜âˆ’1ğ‘(ğœ‡ğ‘˜ , ğ´ğ‘˜ ) ğ‘ğ‘ (ğ›¿ğ‘¥ , ğ‘‘ğœˆ),

P ( X)

ğ‘˜ =1

for all ğ‘ âˆˆ ğ´ğœ‡. Inequality #1 follows from the fact that ğœ‹âˆ— is an optimal policy. Hence, the L.H.S of 38,

âˆ

âˆ— âˆ‘ï¸

ğœ‹
Eğœ‡

ğ›¼ğ‘˜ ğ‘(ğ‘¥ğ‘˜ , ğ´ğ‘˜ ) | ğ‘‹0 = ğ‘¥

ğ‘˜ =0

#=2 ğ‘(ğ›¿ğ‘¥ , ğœ‹âˆ— (ğœ‡))

âˆ«
+ğ›¼
P (ğœ’)

âˆ
Eğœˆğœ‹âˆ— âˆ‘ï¸ ğ›¼ğ‘˜âˆ’1ğ‘(ğœ‡ğ‘˜ , ğ´ğ‘˜ )
ğ‘˜ =1

Ã—ğ‘ ğœ‹âˆ— (ğœ‡) (ğ›¿ğ‘¥, ğ‘‘ğœˆ)

âˆ

âˆ— âˆ‘ï¸

â‰¥

ğœ‹
E

ğ‘˜
ğ›¼

ğ‘

(

ğœ‡ğ‘˜

,

ğ´ğ‘˜

)

.

ğ›¿ğ‘¥

ğ‘˜ =0

Note that in the ï¬rst term of the R.H.S of equality #2, because of the conditioning on {ğ‘‹0 = ğ‘¥} the CMC is in state ğ›¿ğ‘¥ which becomes the ï¬rst argument of ğ‘(Â·, Â·) and the controller or decision maker is only told ğœ‡, which becomes the second argument of ğ‘(Â·, Â·).

11.10 Solving the Time-Average Cost MDP
We use the technique described in [Sen89] to show that the SLQ policy is optimal for the long term timeaveraged cost criterion as well. We consider a sequence of discount factors {ğ›¼ğ‘›} â†‘ 1 and the corresponding discounted optimal policies. We begin with the following result:
10Refer Chapter 4 of [HL89] for details.
47

Lemma 10. ( [Sen89]) Let {ğ›¼ğ‘›} be a sequence of discount factors increasing to 1, and let ğœ‹âˆ— be the associated
ğ‘›
sequence of discounted optimal stationary policies. There exists a subsequence {ğ›¼ğ‘› } and a stationary policy ğ‘˜
ğœ‹âˆ— that is a limit point of ğœ‹âˆ— .
ğ‘›ğ‘˜
The proof of Lemma 10 can be found in [Sen89]. In our case, the assertion is easily seen to be true, since the SLQ policy is optimal for every ğ›¼ âˆˆ (0, 1). To invoke the theorem in [Sen89], we need to ï¬rst show that the conditions assumed therein are true. Towards this end let us ï¬rst limit our MDPâ€™s state space to ğ‘† = N Ã— Nğ‘ Ã— Nğ‘ âˆ’1 Ã— ğ¼ âˆ’ ğ‘†0, where, ğ‘†0 = {ğ‘  âˆˆ N Ã— Nğ‘ Ã— Nğ‘ âˆ’1 Ã— ğ¼ : ğ‘£ğ‘– = ğ‘£ ğ‘— = 0 for some ğ‘— â‰  ğ‘– or ğ‘Ÿ ğ‘— â‰¥ 1 for some ğ‘— âˆˆ ğ¼}. The set ğ‘†0 contains states where multiple coordinates of V(ğ‘¡) are zero and states with ğ‘Ÿ ğ‘— â‰¥ 1. The former class of states is not allowed, since there can be at most one transmitter in any time slot. The latter are all transient states. ğ‘†0 obviously contains the set of transient states induced by the policies under consideration, and needs to be removed so that the resulting controlled DTMC, deï¬ned on ğ‘† , can be irreducible.
Now, the theorem in [Sen89] makes assumptions, which in our case can be restated as follows. For any ğ›¼ âˆˆ (0, 1), and state (ğ‘, V, r, ğ‘–) âˆˆ ğ‘† ,

â€¢ A: ğ½âˆ— ((ğ‘, V, r) < âˆ.
ğ‘–

â€¢

B:

Let11

V0

= 1 âˆ’ Ë†e1

and

deï¬ne

â„ğ‘–,ğ›¼ (ğ‘, V, r)

:=

ğ½âˆ—((ğ‘,
ğ‘–

V,

r)

âˆ’

ğ½1âˆ— ((0,

V0,

0).

There

exists

ğ‘

> 0,

s.t.

â„ğ‘–,ğ›¼ (ğ‘, V, r) â‰¥ âˆ’ğ‘ âˆ€(ğ‘, V, r, ğ‘–) âˆˆ ğ‘† .

(48)

â€¢ C: For any given pair of states (ğ‘ , ğ‘¡) âˆˆ ğ‘† Ã— ğ‘† , and action ğ‘ âˆˆ ğ¼, let ğ‘ƒğ‘ ğ‘¡ (ğ‘) denote the transition probability from state ğ‘  to state ğ‘¡ under action ğ‘ in the MDP (for further details, read Sec.11.6). There exists ğ‘€ğ‘– (ğ‘, V, r) â‰¥ 0, s.t.

â„ğ‘–,ğ›¼ (ğ‘, V, r) â‰¤ ğ‘€ğ‘– (ğ‘, V, r) âˆ€(ğ‘, V, r, ğ‘–) âˆˆ ğ‘† , and ğ›¼ âˆˆ (0, 1),

(49)

and, denoting by ğ‘€ğ‘¡ the R.H.S in the above equation for state ğ‘¡ âˆˆ ğ‘† ,

âˆ‘ï¸

ğ‘€ğ‘¡ ğ‘ƒğ‘ ğ‘¡ (ğ‘) < âˆ, âˆ€ğ‘  âˆˆ ğ‘† and ğ‘ âˆˆ ğ¼.

(50)

ğ‘¡ âˆˆğ‘†

Theorem 11. If the assumptions A, B and C hold, ğœ‹âˆ— is optimal for the Averge Cost problem as well.

Theorem 11 is proved in [Sen89]. To see why A is true, deï¬ne ğ‘ (0) = [ğ‘, V, r, ğ‘–] and consider

âˆï£®

ï£¹

ğ½âˆ— (ğ‘ (0))

=

min Eğœ‹

âˆ‘ï¸ ğ‘› ï£¯ ğ›¼ ï£¯ğ‘„ğ‘¢

âˆ‘ï¸

âˆ‘ï¸

ï£º

(ğ‘›) + ğœ†

ğ‘‰ğ‘— (ğ‘›) + ğ‘…ğ‘– (ğ‘›)ï£º

ğ‘–

ğœ‹ ğ‘  (0)

ğ‘›âˆ’1
ï£¯

ï£º

ğ‘›=0 ï£¯

ğ‘— â‰ ğ‘¢ğ‘›âˆ’1

ğ‘–âˆˆğ¼

ï£º

ï£°

ï£»

âˆï£®

ğ‘’

âˆ‘ï¸ ï£¯

âˆ‘ï¸

â‰¤

min

E

ğœ‹ ğ‘ (

0)

ğ›¼ğ‘› ï£¯ ğ‘„ğ‘¢ğ‘›âˆ’1 (0) + ğ‘› + ğœ† ğ‘› +

ğ‘‰ğ‘— (0)

ğœ‹

ï£¯

ğ‘›=0 ï£¯

ğ‘— â‰ ğ‘¢ğ‘›âˆ’1

ï£°

âˆ‘ï¸ + ğ‘› + ğ‘…ğ‘– (0)
ğ‘–âˆˆğ¼

ğ‘“ âˆ‘âˆï¸ ï£® âˆ‘ï¸

â‰¤

min

E

ğœ‹ ğ‘ (

0

)

ğ‘›
ğ›¼

ï£¯ï£¯ (ğ‘„ (0)

+

ğ‘›)

+

ğœ†

ğ‘›+

ğ‘‰ğ‘— (0)

ğœ‹

ï£¯

ğ‘›=0 ï£¯

ğ‘— â‰ ğ‘¢ğ‘›âˆ’1

ï£°

â˜…
< âˆ,

âˆ‘ï¸ + ğ‘› + ğ‘…ğ‘– (0)
ğ‘–âˆˆğ¼

11We deï¬ne Ë†eğ‘˜ as the vector with 0â€™s at all coordinates except the ğ‘˜ğ‘¡â„, which is equal to 1.

48

where inequality ğ‘’ follows from the fact that over ğ‘› slots, the backlog of queue ğ‘¢ğ‘›âˆ’1 cannot have increased to more than ğ‘› packets over its initial backlog, i.e., ğ‘„ğ‘¢ğ‘›âˆ’1 (0) + ğ‘›. In inequality ğ‘“ , ğ‘„ (0) = maxğ‘˜ âˆˆğ¼ ğ‘„ğ‘˜ (0). Finally,

inequality â˜… uses the fact that

âˆ

âˆ‘ï¸

ğ‘›
ğ‘›ğ›¼

<

âˆ,

âˆ€ğ›¼

âˆˆ

(0, 1).

(51)

ğ‘›=0

In Lemma.7, we have already proven that ğ½âˆ— is increasing in its ï¬rst coordinate. Now, keeping the incumbent the same, suppose one of the coordinates of V is increased,

ğ½âˆ— (0; V; 0)

=

âˆ‘ï¸ ğœ† ğ‘‰ğ‘˜

+

ğ›¼ min Eğ½âˆ—

(ğµ(ğ‘‰ğ‘˜ ); ğ‘‰ğ‘˜

=

0, Vâˆ’ğ‘˜

+

1; 0)

ğ‘–

ğ‘˜â‰ ğ‘– ğ‘—

ğ‘˜ â‰ ğ‘–

â‰¤

âˆ‘ï¸ ğœ†(ğ‘‰ + 1) + ğœ† ğ‘‰

+ ğ›¼ min

min

âˆ—
Eğ½

(

ğµ(ğ‘‰

);

ğ‘™

ğ‘˜

ğ‘˜â‰ ğ‘–,ğ‘™ ğ‘—

ğ‘˜

ğ‘˜ â‰ ğ‘– ,ğ‘™

ğ‘‰ğ‘˜ = 0, Vâˆ’ğ‘˜ + 1 + Ë†eğ‘™; 0) , ğ½âˆ— (ğµ(ğ‘‰ğ‘™ + 1); ğ‘‰ğ‘™ = 0, Vâˆ’ğ‘˜ + 1; 0)
ğ‘™
= ğ½ğ‘–âˆ— (0; V + Ë†eğ‘™; 0). (52)

A similar analysis proves that ğ½âˆ— is increasing in the coordinates of r also. Finally, starting with a diï¬€erent
incumbent, since ğ½ğ‘™âˆ— (0; V; 0) = ğœ† âˆ‘ï¸ ğ‘‰ğ‘˜ + ğ›¼ min Eğ½âˆ—ğ‘— (ğµ(ğ‘‰ğ‘˜ ); ğ‘‰ğ‘˜ = 0, Vâˆ’ğ‘˜ + 1; 0) , (53)
ğ‘˜ â‰ ğ‘™ ğ‘˜ â‰ ğ‘™

we see that if ğ‘‰ğ‘™ in the ï¬rst equation of (52) is equal to ğ‘‰ğ‘– in (53), then ğ½âˆ— (0; V; 0) = ğ½âˆ— (0; V; 0). This is

ğ‘™

ğ‘–

achieved by noting that all since arrivals are statistically identical and independent one can simply route the

packets of queue ğ‘™ to queue ğ‘– and vice versa in every sample path. This doesnâ€™t change the statistics of the

system in any way and proves that

ğ½âˆ—((ğ‘,
ğ‘–

V,

r)

âˆ’

ğ½1âˆ— ((0,

V0,

0)

=

â„ğ‘–,ğ›¼ (ğ‘,

V,

r)

â‰¥

0

âˆ€ğ‘–

âˆˆ

ğ¼.

(54)

Proving assumption C is nontrivial, and Prop. 5 (pp.629) in [Sen89] gives a suï¬ƒcient condition for C to hold.
Lemma 12. Assume that the MDP has a stationary policy ğ‘“ that induces an irreducible, positive recurrent Markov chain on the state space of the problem, viz, ğ‘† . Let ğ‘ ğ‘“ (ğ‘, V, r, ğ‘–) denote the invariant distribution of the chain and let ğ‘ ğ‘“ (ğ‘, V, r, ğ‘–) denote the non-negative cost in state s = [ğ‘; V; r; ğ‘–]. If

ï£®

ğ‘ï£¹

âˆ‘ï¸ ğ‘

(ğ‘, V, r, ğ‘–)ğ‘

(ğ‘, V, r, ğ‘–) = E ï£¯ï£¯ğ‘„Ëœ + ğœ† âˆ‘ï¸ ğ‘‰Ëœ

âˆ‘ï¸ ï£º + ğ‘ŸËœ ï£º < âˆ

(55)

ğ‘“

ğ‘“

ğ‘˜

ğ‘™

ï£¯

ï£º

s

ï£¯

ğ‘˜ â‰ Ëœğ‘–

ğ‘™=1 ï£º

ï£°

ï£»

then assumption C is true. Here, ğ‘„Ëœ, VËœ , Ëœr and Ëœğ‘– are the random variables with joint distribution ğ‘ ğ‘“ . Notice, however, from (10) that for all policies under consideration that are also stabilizing,

ï£®

ğ‘ï£¹

ğ‘

E ï£¯ï£¯ğ‘„Ëœ + ğœ† âˆ‘ï¸ ğ‘‰Ëœ

âˆ‘ï¸ ï£º + ğ‘ŸËœ ï£º

=

E

E

âˆ‘ï¸ ğ‘„

ğ‘„Ëœ, VËœ

ğ‘˜

ğ‘™

ğ‘˜

ï£¯

ï£º

ï£¯

ğ‘˜ â‰ Ëœğ‘–

ğ‘™=1 ï£º

ğ‘˜ =1

ï£°

ï£»

ğ‘

âˆ‘ï¸

= E ğ‘„ğ‘˜,

(56)

ğ‘˜ =1

where [ğ‘„1, . . . , ğ‘„ ğ‘ ] is the stationary queue-length vector of the system. We have already shown that ğœ‹âˆ— is stabilizing and know that the policy discussed in Sec. 4.5.4, ğœ‹ , is also stabilizing from the discussion therein.

49

Time Slot
ğ‘¡ ğ‘¡+1 ğ‘¡+2
ğ‘¡+3 . . . ğ‘¡

V1 (Â·) (incumbent) [0, 9, 11, 12] [0, 10, 12, 13] [0, 11, 13, 14]
[0, 12, 14, 15]
[0, 11, 13, 14]

V2 (Â·)
[0, 9, 11, 12] [0, 10, 12, 13] [1âˆ—, 11, 13, 0] [0, 11, 13, 14] [0, 12, 14, 15]
[0, 11, 13, 14]

V3 (Â·)
[0, 9, 11, 12] [0, 10, 12, 13] [0, 11, 13, 14] [0, 12, 14, 15]
[0, 11, 13, 14]

V4 (Â·) (ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥ğ‘–ğ‘‰ğ‘– (ğ‘¡) = 4)
[0, 9, 11, 12] [0, 10, 12, 13] [0, 11, 13, 14]
[1âˆ—, 12, 14, 0] â† Queue 4 nonempty
[1âˆ—, 11, 13, 0] â† Queue 4 empty [0, 11, 13, 14]

Table 2: Illustrating the three types of CCA errors and the resulting ğ‘‰ -vector misalignment. The network here comprises 4 nodes and the 4 columns represent local copies of the ğ‘‰ -vector (i.e., Vğ‘– (ğ‘¡) is the copy of the ğ‘‰ -vector at Node ğ‘–). In the situation considered here, Node 1 is the incumbent and ğ‘ğ‘Ÿ ğ‘” ğ‘šğ‘ğ‘¥1â‰¤ğ‘–â‰¤4ğ‘‰ğ‘– (ğ‘¡) = 4. The coordinate at which CCA error occurs is denoted by an asterisk (âˆ—). A red to blue transition implies the node detects (infers) a misalignment and also corrects it within the same time slot.

So, we set ğ‘“ â‰¡ ğœ‹ , since ğœ‹ is stationary and Markov, and observe that for any ğœ† âˆˆ [0, 1 ) queueing delay
ğ‘

for such policies is ï¬nite. Using Littleâ€™s law, we see that under ğœ‹ , E

ğ‘
ğ‘˜=1 ğ‘„ ğ‘˜

=

ğ‘
ğ‘˜=1 Eğ‘„ğ‘˜

<

âˆ.

Since ğœ‹

is

stationary, this proves the claim and establishes the fact that ğœ‹âˆ— is optimal for the average cost criterion as

well.

11.11 Proof of Prop. 6

Let Z+ denote the non negative integers. The proof uses a simple mean drift argument with a novel Lyapunov function. Deï¬ne ğ¿ : Z2+ğ‘ â†¦â†’ R+ as

ğ‘

2

âˆ‘ï¸

ğ¿ (ğ‘ (ğ‘¡)) := ğ‘„ ğ‘— (ğ‘¡ âˆ’ ğ‘‰ğ‘— (ğ‘¡)) + ğœ† ğ‘—ğ‘‰ğ‘— (ğ‘¡) + ğ‘‰ğ‘— (ğ‘¡)ğœ† ğ‘— (1 âˆ’ ğœ† ğ‘— ).

(57)

ğ‘— =1

We will prove that a policy that is clearly suboptimal (refer Fig. 17), again, w.r.t. delay when compared to ğœ‹ğ¾ (meaning it idles more than ğœ‹ğ¾ ) is also stabilizing. This new policy, called â€œGated K Limited serviceâ€(GKLS) policy and denoted by ğœ‰ğ¾ , serves only those packets that were in the chosen queue at the beginning of service, for a maximum of ğ¾ slots. Also, once a queue is chosen for service, the server stays at it (idling, if necessary), for ğ¾ slots at the end of which ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥1â‰¤ğ‘–â‰¤ğ‘ (ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ğ‘– (ğ‘¡)) + ğœ†ğ‘–ğ‘‰ğ‘– (ğ‘¡)) is chosen for service for the next ğ¾ slots.
For example, suppose ğ¾ = 5 and queue 3 has been chosen for service. At the beginning of service, suppose ğ‘„3 = 2 and over the course of the 5 slots, it receives 4 more packets. Then ğœ‰ğ¾ serves only the 2 that were in Queue 3 at the beginning of service, does not serve any of the 4 new packets and idles for the remaining ğ¾ âˆ’ 2(= 3) slots. This is clearly suboptimal compared to ğœ‹ğ¾ which would have served 5 packets and left queue 3 with just 1 packet at the end of ğ¾ = 5 slots.
Suppose at time ğ‘¡, ğœ‰ğ¾ switches to queue ğ‘–. For all other queues, after K slots, ğ‘‰ğ‘™ (ğ‘¡ + ğ¾) = ğ‘‰ğ‘™ (ğ‘¡) + ğ¾, and ğ‘„ğ‘™ (ğ‘¡ + ğ¾ âˆ’ ğ‘‰ğ‘™ (ğ‘¡ + ğ¾)) = ğ‘„ğ‘™ (ğ‘¡ âˆ’ ğ‘‰ğ‘™ (ğ‘¡)). Therefore, at the end of ğ¾ slots, the new state is ğ‘ (ğ‘¡ + ğ¾) = [ğ‘„1 (ğ‘¡ âˆ’ ğ‘‰1 (ğ‘¡)), . . . , ğ‘„ğ‘–âˆ’1 (ğ‘¡ âˆ’ ğ‘‰ğ‘–âˆ’1 (ğ‘¡)), ğ‘„ğ‘– (ğ‘¡ + ğ¾), ğ‘„ğ‘–+1 (ğ‘¡ âˆ’ ğ‘‰ğ‘–+1 (ğ‘¡)), . . . , ğ‘„ ğ‘ (ğ‘¡ âˆ’ ğ‘‰ğ‘ (ğ‘¡)), ğ‘‰1 (ğ‘¡) + ğ¾, . . . , ğ‘‰ğ‘–âˆ’1 (ğ‘¡) + ğ¾, 0, ğ‘‰ğ‘–+1 (ğ‘¡) + ğ¾, . . . , ğ‘‰ğ‘ (ğ‘¡) + ğ¾]. Invoking the linearity of conditional expectation, computing the expected conditional drift can be split into contributions by the queue chosen for service at time ğ‘¡, i.e., queue ğ‘–, and that by the

50

Expected Delay (slots)

System with 20 queues 90
80 70 KLEQ (Ï€K): K = 2
GKLS (Î¾K): k = 2 60
50
40
30
20
10
0 0.005 0.01 0.015 0.02 0.025 0.03 0.035 0.04 0.045 0.05
Î£i Î»i (pkts/s)
Figure 17: Illustrating the suboptimality of the Gated K Limited service policy ( ğœ‰ğ¾ ).

other queues. For simplicity we drop the time indices and denote ğ‘‰ğ‘— (ğ‘¡) by ğ‘‰ğ‘— for the remainder of the proof.

E [ğ¿(ğ‘ (ğ‘¡ + ğ¾)) âˆ’ ğ¿(ğ‘ (ğ‘¡))|ğ‘ (ğ‘¡)]

=

E

ğ‘„2 (ğ‘¡

+ ğ¾)

âˆ’

(ğ‘„ğ‘– (ğ‘¡

âˆ’ ğ‘‰ğ‘–)

+ ğœ† ğ‘‰ )2
ğ‘–ğ‘–

âˆ’ ğ‘‰ğ‘–ğœ†ğ‘– (1 âˆ’ ğœ†ğ‘–)

ğ‘ (ğ‘¡)

+

ğ‘–

âˆ‘ï¸

E

ğ‘„ ğ‘— (ğ‘¡ âˆ’ ğ‘‰ğ‘—) + ğœ† ğ‘— ğ‘‰ğ‘— + ğ¾

2 + ğ‘‰ğ‘— + ğ¾ ğœ† ğ‘— (1 âˆ’ ğœ† ğ‘—) âˆ’

ğ‘— â‰ ğ‘–

âˆ‘ï¸ ğ‘„ ğ‘— (ğ‘¡ âˆ’ ğ‘‰ğ‘— ) + ğœ† ğ‘—ğ‘‰ğ‘— 2 + ğ‘‰ğ‘— ğœ† ğ‘— (1 âˆ’ ğœ† ğ‘— ) ğ‘ (ğ‘¡) (58)
ğ‘— â‰ ğ‘–

The contribution to ğ¿(ğ‘ (ğ‘¡ + ğ¾)) of all queues ğ‘— other than ğ‘– is

âˆ‘ï¸ ğ‘„ ğ‘— (ğ‘¡ âˆ’ ğ‘‰ğ‘— ) + ğœ† ğ‘— ğ‘‰ğ‘— + ğ¾ 2 + ğ‘‰ğ‘— + ğ¾ ğœ† ğ‘— (1 âˆ’ ğœ† ğ‘— )
ğ‘— â‰ ğ‘–

= âˆ‘ï¸ ğ‘„ ğ‘— (ğ‘¡ âˆ’ ğ‘‰ğ‘— ) + ğœ† ğ‘—ğ‘‰ğ‘— 2 + 2ğ¾ ğ‘„ ğ‘— (ğ‘¡ âˆ’ ğ‘‰ğ‘— ) + ğœ† ğ‘—ğ‘‰ğ‘— ğœ† ğ‘—
ğ‘— â‰ ğ‘–

+ğ¾2ğœ†2 + ğ‘‰ğ‘—ğœ† ğ‘— (1 âˆ’ ğœ† ğ‘— ) + ğ¾ğœ† ğ‘— (1 âˆ’ ğœ† ğ‘— ).

(59)

ğ‘—

Using (59), the second term on the R.H.S of (58) becomes

âˆ‘ï¸

E

ğ‘„ ğ‘— (ğ‘¡ âˆ’ ğ‘‰ğ‘—) + ğœ† ğ‘— ğ‘‰ğ‘— + ğ¾

2 + ğ‘‰ğ‘— + ğ¾ ğœ† ğ‘— (1 âˆ’ ğœ† ğ‘—)

ğ‘— â‰ ğ‘–

âˆ’ âˆ‘ï¸ ğ‘„ ğ‘— (ğ‘¡ âˆ’ ğ‘‰ğ‘— ) + ğœ† ğ‘—ğ‘‰ğ‘— 2 + ğ‘‰ğ‘— ğœ† ğ‘— (1 âˆ’ ğœ† ğ‘— ) ğ‘ (ğ‘¡)
ğ‘— â‰ ğ‘–

= E 2ğ¾ ğ‘„ ğ‘— (ğ‘¡ âˆ’ ğ‘‰ğ‘— ) + ğœ† ğ‘—ğ‘‰ğ‘— ğœ† ğ‘— + ğ¾2ğœ†2 + ğ¾ğœ† ğ‘— (1 âˆ’ ğœ† ğ‘— ) ğ‘ (ğ‘¡)
ğ‘—

= 2ğ¾ ğ‘„ ğ‘— (ğ‘¡ âˆ’ ğ‘‰ğ‘— ) + ğœ† ğ‘—ğ‘‰ğ‘— ğœ† ğ‘— + ğ¾2ğœ†2 + ğ¾ğœ† ğ‘— (1 âˆ’ ğœ† ğ‘— ),

(60)

ğ‘—

where the last equality follows since the term inside the expectation is a function of ğ‘ (ğ‘¡). Proceeding to queue ğ‘–, we see that

ğ‘„2(ğ‘¡ + ğ¾)

(âˆ—ğ‘)
=

(ğ‘„

(ğ‘¡ âˆ’ ğ‘‰ ) + ğ´

[ğ‘¡ âˆ’ ğ‘‰

+ 1, ğ‘¡] âˆ’ ğ¾)+ + ğ´

[ğ‘¡ + 1, ğ‘¡ + ğ¾]

2
,

ğ‘–

ğ‘–

ğ‘–

ğ‘–

ğ‘–

ğ‘–

(âˆ—ğ‘)
â‰¤ (ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ğ‘–) + ğ´ğ‘– [ğ‘¡ âˆ’ ğ‘‰ğ‘– + 1, ğ‘¡])2 + ğ¾2 + ( ğ´ğ‘– [ğ‘¡ + 1, ğ‘¡ + ğ¾])2

âˆ’2 (ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ğ‘–) + ğ´ğ‘– [ğ‘¡ âˆ’ ğ‘‰ğ‘–, ğ‘¡]) (ğ¾ âˆ’ ğ´ğ‘– [ğ‘¡ + 1, ğ‘¡ + ğ¾]),

(61)

51

where, in equality (âˆ—ğ‘), one ï¬rst needs to note that queue ğ‘– has never been served since ğ‘¡ âˆ’ ğ‘‰ğ‘–. Also, ğ´ğ‘– [ğ‘¥, ğ‘¦] denotes the cumulative arrivals to queue ğ‘– over the time period [ğ‘¥, ğ‘¦], and ğ´ğ‘– [ğ‘¥, ğ‘¥] is the arrival over the single slot ğ‘¥. Speciï¬cally, when the arrival process is Bernoulli, ğ´ğ‘– [ğ‘¥, ğ‘¦] has the distribution Binomial(ğ‘¦ âˆ’ ğ‘¥ + 1, ğœ†ğ‘–). Also, (âˆ—ğ‘) follows from the fact that for any three nonnegative numbers ğ‘¥, ğ‘¦ and ğ‘§, ((ğ‘¥ âˆ’ ğ‘¦)+ + ğ‘§)2 â‰¤ ğ‘¥2 + ğ‘¦2 + ğ‘§2 âˆ’ 2ğ‘¥(ğ‘¦ âˆ’ ğ‘§). In what follows, we use the fact that if a random variable ğ‘‹ âˆ¼Binomial(ğ‘š, ğ‘), then Eğ‘‹2 = ğ‘šğ‘(1 âˆ’ ğ‘) + ğ‘š2ğ‘2.
E ğ‘„2ğ‘– (ğ‘¡ + ğ¾) ğ‘ (ğ‘¡) â‰¤ E (ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ğ‘–) + ğ´ğ‘– [ğ‘¡ âˆ’ ğ‘‰ğ‘– + 1, ğ‘¡])2 + ğ¾2
+ ( ğ´ğ‘– [ğ‘¡ + 1, ğ‘¡ + ğ¾])2 âˆ’
2 (ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ğ‘–) + ğ´ğ‘– [ğ‘¡ âˆ’ ğ‘‰ğ‘– + 1, ğ‘¡])

Ã— (ğ¾ âˆ’ ğ´ğ‘– [ğ‘¡ + 1, ğ‘¡ + ğ¾]) ğ‘ (ğ‘¡)

(âˆ—ğ‘)
=

ğ‘„2 (ğ‘¡ âˆ’ ğ‘‰ ) + 2ğœ† ğ‘‰ ğ‘„ (ğ‘¡ âˆ’ ğ‘‰ ) + ğ‘‰ ğœ† (1 âˆ’ ğœ† )

ğ‘–

ğ‘–

ğ‘–ğ‘– ğ‘–

ğ‘–

ğ‘–ğ‘–

ğ‘–

+ğ‘‰ 2ğœ†2 + ğ¾2 + ğ¾ğœ†ğ‘– (1 âˆ’ ğœ†ğ‘–) + ğ¾2ğœ†2

ğ‘–ğ‘–

ğ‘–

âˆ’2 (ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ğ‘–) + ğœ†ğ‘–ğ‘‰ğ‘–) ğ¾ (1 âˆ’ ğœ†ğ‘–) .

In (âˆ—ğ‘), one needs to note that the arrivals that enter queue ğ‘– after the last time queue ğ‘– was served, viz., ğ´ğ‘– [ğ‘¡ âˆ’ ğ‘‰ğ‘–, ğ‘¡ + ğ¾], are independent of ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ğ‘–). With this, the contribution of queue ğ‘– to the expected drift (the ï¬rst term on the R.H.S of (58)) is

E

ğ‘„2 (ğ‘¡

+ ğ¾)

âˆ’

(ğ‘„ğ‘– (ğ‘¡

âˆ’ ğ‘‰ğ‘–)

+ ğœ† ğ‘‰ )2
ğ‘–ğ‘–

âˆ’ ğ‘‰ğ‘–ğœ†ğ‘– (1 âˆ’ ğœ†ğ‘–)

ğ‘ (ğ‘¡)

ğ‘–

â‰¤ ğ¾2 + ğ¾ğœ†ğ‘– (1 âˆ’ ğœ†ğ‘–) + ğ¾2ğœ†2
ğ‘–

+2ğ¾ğœ†ğ‘– (ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ğ‘–) + ğœ†ğ‘–ğ‘‰ğ‘–) âˆ’ 2ğ¾ (ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ğ‘–) + ğœ†ğ‘–ğ‘‰ğ‘–)

(62)

We are now in a position to compute the expected drift. Deï¬ne ğœ– := 1 âˆ’ ğ‘— ğœ† ğ‘— , strictly positive, by assumption. Using (60) and (62) in (58), we get

E [ğ¿(ğ‘ (ğ‘¡ + ğ¾)) âˆ’ ğ¿(ğ‘ (ğ‘¡))|ğ‘ (ğ‘¡)] â‰¤

ğ‘

ğ‘

ğ¾ (ğ¾ âˆ’ 1) âˆ‘ï¸ ğœ†2ğ‘— + ğ¾ âˆ‘ï¸ ğœ† ğ‘— + ğ¾2

ğ‘— =1

ğ‘— =1

ğ‘
âˆ‘ï¸ âˆ’2ğ¾ (ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ğ‘–) + ğœ†ğ‘–ğ‘‰ğ‘–) 1 âˆ’ ğœ†ğ‘™
ğ‘™=1
< âˆ’ğœ–,

whenever

ğ¾ (ğ¾ âˆ’ 1) ğ‘šğ‘ğ‘¥ğ‘– (ğ‘„ğ‘– (ğ‘¡ âˆ’ ğ‘‰ğ‘–) + ğœ†ğ‘–ğ‘‰ğ‘–) >

ğ‘ğ‘—=1 ğœ†2ğ‘— + ğ¾ 2ğ¾ğœ–

ğ‘ ğ‘— =1

ğœ†ğ‘—

+

ğ¾2

1

+,

2ğ¾

Invoking the Foster Lyapunov theorem [FMM95] we see that the DTMC {ğ‘ (ğ¾ğ‘¡), ğ‘¡ â‰¥ 0} is positive recurrent.

To show that ğ‘ (ğ‘¡) is positive recurrent as well, we invoke the following lemma.

Lemma 13. Let {ğ‘‹ (ğ‘¡), ğ‘¡ â‰¥ 0} be an aperiodic and irreducible DTMC over a countable state space. Deï¬ne ğ‘Œ (ğ‘¡) := ğ‘‹ (ğ¾ğ‘¡), âˆ€ğ‘¡ â‰¥ 0, for some positive integer ğ¾. If ğ‘Œ (ğ‘¡) is positive recurrent, then so is ğ‘‹ (ğ‘¡).

Proof. Given any ğ‘— âˆˆ N, suppose the mean recurrence time of ğ‘— in ğ‘Œ (ğ‘¡) is denoted by ğœˆ(ğ¾) , and in ğ‘‹ (ğ‘¡) by
ğ‘—
ğœˆ ğ‘— . Clearly, starting from any state ğ‘—, every time ğ‘‹ (ğ¾ğ‘¡) hits ğ‘—, so does ğ‘‹ (ğ‘¡). This means that ğœˆ(ğ‘—ğ¾) â‰¥ ğœˆ ğ‘— and since ğœˆ(ğ‘—ğ¾) < âˆ, so is ğœˆ ğ‘— , showing that ğ‘‹ (ğ‘¡) is also positive recurrent.

Thus, ğ‘ (ğ‘¡) is also positive recurrent, and the proof of Prop. 6 concludes.

52

11.12 Channel Errors and Fading

Until now, we have assumed that all transmission attempts succeed ğ‘¤.ğ‘.1. In this section, we consider a system similar to the one described in [TE93]. In addition to the system described in Sec. 2, we also specify that every transmission from queue ğ‘– succeeds with probability ğ‘ğ‘– independent of all other transmissions. Speciï¬cally, fading or transmission errors are independent across time slots. This necessitates a revision of Eqn. 2, provided in Eqn. (63) wherein the random variables ğ¶ğ‘– (ğ‘¡), that represent the fade state of the channel between node ğ‘– and the receiver, are modelled as Bernoulli random variables i.i.d across time and independent across queues.

ğ‘„ğ‘– (ğ‘¡ + 1) = (ğ‘„ğ‘– (ğ‘¡) âˆ’ ğ¶ğ‘– (ğ‘¡)ğ·ğ‘– (ğ‘¡))+ + ğ´ğ‘– (ğ‘¡ + 1),

ğ‘„ğ‘– (0) = ğ´ğ‘– (0).

(63)

The coeï¬ƒcient of ğ·ğ‘– (ğ‘¡) in (63) is âˆ’ğ¶ğ‘– (ğ‘¡) âˆˆ {0, âˆ’1}, meaning Queue ğ‘–â€™s transmissions are assumed to succeed

whenever it is scheduled (ğ·ğ‘– (ğ‘¡) = 1) and its channel is â€œONâ€ (ğ¶ğ‘– (ğ‘¡) = 1). We assume the system only gets

to know whether a transmission succeeded or not at the end of a slot and has no knowledge of the current

channel state at the scheduling instants. Since each packet at Queue ğ‘– takes, on the average, 1/ğ‘ğ‘– slots to

be transmitted (i.e., its service time is Geometric with mean 1/ğ‘ğ‘–), the capacity region of such a system is

given by

ğ‘

Î› :=

ğ€

âˆˆ

ğ‘
R+

âˆ‘ï¸ ğœ†ğ‘–

<1

,

(64)

ğ‘–=1 ğ‘ğ‘–

It can be shown that the proof of Prop. 2 remains valid even when the service time of Queue ğ‘– is ğµğ‘– and
ğ‘–ğ‘=1 ğœ†ğ‘–Eğµğ‘– < 1. Setting Eğµğ‘– = ğ‘1ğ‘– we see that the LEQ policy, clearly, is still throughput optimal. Note that the LEQ scheduler does not need to know the fading probabilities {ğ‘1, ğ‘2, Â· Â· Â· , ğ‘ğ‘ } to stabilize the system.

11.13 Handling Alarm Traï¬ƒc: The QZMACğ‘ protocol
Alarm traï¬ƒc is particularly important in in-network processing, wherein the data generated by the sensors is partially processed within the network before reaching the sink etc. [LRZ03, YG02, YHE02]. This is done, as mentioned earlier, to detect abnormal behavior in the processes begin monitored by the WSN and when such conditions are detected, the network generates alarm packets. To study the eï¬€ects of applications generating alarm packets that need to be delivered with utmost priority, we ï¬rst modify the system described in Sec. 2. Instead of a single arrival stream, every queue now has two arrival streams. One carrying non alarm traï¬ƒc (which we will call data traï¬ƒc) and another carrying alarm packets. The Bernoulli ğœ†ğ‘– input process is split (in a memoryless manner) with a fraction 1 âˆ’ ğ›¼ğ‘– entering the data stream and a fraction ğ›¼ğ‘– entering the alarm packet stream. Given that alarm packets are generated very rarely ğ›¼ğ‘– is much smaller than 1 âˆ’ ğ›¼ğ‘–. In this case, we modify QZMAC as follows. We include an alarm minislot (ğ‘‡ğ‘) at the beginning of every slot. Queues with alarm packets can use this slot to send out a high power jamming signal to inform the others that alarm packets are in the system. With this, we modify QZMAC to accommodate such traï¬ƒc and call the resulting protocol QZMACğ‘. So, at the beginning of slot ğ‘¡
â€¢ The slot begins with the alarm minislot ğ‘‡ğ‘. Every queue that has an alarm packet sends out a jam signal.
â€¢ If the queues do not sense any power in ğ‘‡ğ‘, QZMACğ‘ operates exactly like QZMAC in slot ğ‘¡.
â€¢ If the queues do sense power in ğ‘‡ğ‘, normal operation according to QZMAC is suspended for slot ğ‘¡.

53

ğ´1 (ğ‘¡) ğ´2 (ğ‘¡)

ğºğ‘’ğ‘œ [ğ‘‹ ] /ğ·/1

ğ´ğ‘ (ğ‘¡) (a) Operation of the idealized full knowledge scheduler.

ğ´1(ğ‘) (ğ‘¡) ğ´2(ğ‘) (ğ‘¡) ğ´ğ‘ (ğ‘¡)
ğ´1 (ğ‘¡) ğ´2 (ğ‘¡) ğ´ğ‘ (ğ‘¡)

Alarm Packets

Higher Priority

Data Packets

Lower Priority (Serve only if alarm queue is empty)

(b) Operation of the idealized full knowledge scheduler with pri-

ority service for alarm packets. With alarm traï¬ƒc, it becomes a

priority queue.

(
ğ´

ğ‘

)

(

ğ‘¡

)

is the alarm packet entering queue ğ‘– at

ğ‘–

time t.

Figure 18: Operation of the idealized full knowledge scheduler with priority service for alarm packets.

â€“ All queues with alarm packets back oï¬€ as usual over {ğ‘‡ğ‘ + ğ‘‡ğ‘ + 1, Â· Â· Â· , ğ‘‡ğ‘ + ğ‘‡ğ‘ + ğ‘‡ğ‘ } and if a winner emerges, it transmits its alarm packet.
â€“ If no winner emerges, the system still has alarm packets, which means the protocol goes into alarm mode in slot ğ‘¡ + 1 as well.
â€“ This continues until there are no alarm packets left in the system.

11.13.1 Performance of QZMAC with Alarm Traï¬ƒc
As can be seen from Fig. 19a, when alarm traï¬ƒc is light QZMACğ‘ provides the same delay to alarm packets as the full knowledge scheduler (the plain red and plan blue curves overlap signiï¬cantly). This is because alarm packets are given maximum priority in QZMACğ‘. Queues with alarm packets contend for the channel and since their arrival rate (ğ›¼ğ‘–ğœ†ğ‘–) is small, these packets essentially see a service time of 1 slot. Moreover, the delay to data traï¬ƒc (blue-with-diamonds curve) is comparable to that without any alarm traï¬ƒc (dashed green curve), i.e., plain QZMAC. However, if the alarm traï¬ƒc load becomes signiï¬cant compared to data traï¬ƒc, the performance delivered to alarm packets (solid red curve at the bottom of Fig. 19b) is not aï¬€ected much due to priority queueing (this delay does show an increase near saturation from 1.005 slots to 1.357 slots, but this is still acceptable). However, the delay of data packets (blue-with-diamonds curve) degrades considerably and, as Fig. 19b shows, is much worse than that of QZMAC without any alarm traï¬ƒc (dashed green curve). The curves in red are obtained by the full-knowledge scheduler with priorities (see Fig. 18b).

11.14 Eï¬€ects of Nonidealities in Clear Channel Assessment
As mentioned earlier, in standard hypothesis testing parlance, the event when a CCA fails despite there being no activity on the channel is called a â€œFale Alarm,â€ while the event when the CCA is successful even when a node in the network is transmitting is called a â€œMiss.â€ We denote the corresponding probabilities by ğ‘ğ¹ ğ´ and ğ‘ğ‘šğ‘–ğ‘ ğ‘  respectively. Our extensive experimentation, as described in Sec. 8, has revealed the following facts

54

Symmetric system with 30 queues (Î± = 1%) Geo[X]/D/1 (without alarm traffic) Geo[X]/D/1 (alarm) Geo[X]/D/1 (data) QZMAC (alarm)
a QZMAC (data)
a QZMAC (without alarm traffic) Geo[X]/D/1 (without alarm traffic); black curve
Geo[X]/D/1 (data); red curve
QZMAC (alarm) overlaps with Geo[X]/D/1 (alarm) a

0.005

0.01

0.015

0.02

Î» (pkts/slot)

0.025

0.03

Delay (slots)

90 80 70 60 50 40 30 20 10
0 0

Symmetric system with 30 queues (Î± = 33%)
Geo[X]/D/1 (without alarm traffic) Geo[X]/D/1 (alarm) Geo[X]/D/1 (data) QZMAC (alarm)
a QZMAC (data)
a QZMAC (without alarm traffic)
QZMAC (alarm) overlaps with Geo[X]/D/1 (alarm) a

0.005

0.01

0.015

0.02

Î» (pkts/slot)

0.025

0.03

0.035

(a) Performance of QZMACğ‘ with ğ›¼ğ‘– = 0.01 for all ğ‘–, i.e., 1% (b) Performance of QZMACğ‘ with ğ›¼ğ‘– = 0.33 for all ğ‘–, i.e., 33%

alarm traï¬ƒc.

alarm traï¬ƒc.

Figure 19: Performance of QZMACğ‘ with diï¬€erent alarm traï¬ƒc arrival rates.

â€¢ For networks with diameter up to 8 meters, ğ‘ğ¹ ğ´ â‰ˆ 0. This happens because the noise ï¬‚oor of modern sensors is low enough (-110 dBm for a 2MHz bandwidth) that no CCA failure triggers when the channel is free, and
â€¢ In any given time slot (not minislot), at most one CCA â€œMissâ€ occurs.
Therefore, going forward, our analysis will assume that only â€œMissâ€ events occur and at most one nodeâ€™s CCA can register a spurious failure in any time slot. Table 2 illustrates the three types of misalignment that can occur. In the sequel, we will refer to them as â€œM1,â€ â€œM2â€ and â€œM3â€ errors. We now describe them in detail and explain how each type is resolved. Recall that the node currently transmitting is called the incumbent and in time slot ğ‘¡, ğ‘–âˆ— = ğ‘ğ‘Ÿğ‘” ğ‘šğ‘ğ‘¥ğ‘–âˆˆ[ğ‘ ]ğ‘‰ğ‘– (ğ‘¡).
M1. This is the situation in slot ğ‘¡ + 2 in Table 2. The CCA of Node ğ‘— ( ğ‘— â‰  ğ‘–âˆ—) succeeds, and it assumes that Node ğ‘–âˆ— will now transmit. However, upon decoding the header, the node discovers that the incumbent is nonempty, infers that a CCA Miss has occurred and corrects its copy of the V-vector.
M2. This is the situation in slot ğ‘¡ + 3 in Table 2. The ğ‘–âˆ— Node assumes that the incumbent is empty and, being nonempty, begins transmitting. The transmissions from the two nodes now collide and further provisions are now required within QZMAC to extricate the network from this state. The subroutine discussed in Sec. 7.2 is designed to accomplish this.
M3. This is the situation in slot ğ‘¡ in Table 2. This case is similar to M2., but now, Node ğ‘–âˆ— is empty. The node then decodes the header of the packet, detects the CCA miss and corrects its copy of the V-vector.
We thus see that two of the three potential types of misalignment can be detected and rectiï¬ed quite easily, while only one necessitates modiï¬cation to QZMAC. In Sec. 7.2 we discuss this modiï¬cation. Furthermore, as the simulation results in Fig. 20 show, even at a miss rate ğ‘ğ‘šğ‘–ğ‘ ğ‘  = 3 Ã— 10âˆ’4, which is 100 times larger than the measures miss probability, the largest increase in mean delay due to the modiï¬cation is 1.5266 slots (â‰ˆ 4.32%), which is quite minimal.

55

Impact of CCA errors on QZMAC (symmetric system 30 queues) 120

p miss =3 10 -6

100

p =3 10 -4

miss

p miss =3 10 -3

80 p miss =3 10 -2

Perfect CCA

60

Expected Delay (slots)

40

20

0 0.025

0.026

0.027

0.028

0.029

0.03

(pkts/slot)

0.031

0.032

0.033

Figure 20: Comparing mean delay with and without CCA errors. We ran QZMAC for 5.25 Ã— 106 slots with ğ¾ğ‘¡ = 5 slots. The
curve in red shows the performance of QZMAC with the RESET subroutine described in Sec. 7.2. Mean delay loss with due to imperfect CCA is at most 1.5266 slots (occurring at ğœ† = 0.0325) even up to a CCA miss probability of 3 Ã— 10âˆ’4, which is quite
negligible.

56

